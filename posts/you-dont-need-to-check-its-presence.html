<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Functional Programming, Java, Optional, Monads">
<meta name="author" content="Daniel Łaś">
<title>Daniel Łaś Tech Blog - You don't need to check its presence. Anatomy of Optional and why you are using it wrong.</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
<link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet'
	type='text/css'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.css">
<link href="../css/clean-blog.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js" data-manual></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12045869-7"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'UA-12045869-7');
</script>
</head>
<body>
	<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
		<div class="container">
			<a class="navbar-brand" href="../index.html">Home</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive"
				aria-expanded="false" aria-label="Toggle navigation">
				Menu <i class="fas fa-bars"></i>
			</button>
			<div class="collapse navbar-collapse" id="navbarResponsive">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link" href="../index.html">Home</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../about.html">About</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../contact.html">Contact</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>
	<header class="masthead sm">
		<div class="overlay"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<div class="post-heading text-center">
						<h1>You don't need to check its presence</h1>
						<h2 class="subheading">Anatomy of Optional and why you are using it wrong.</h2>
					</div>
				</div>
			</div>
		</div>
	</header>
	<article>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<ul class="list-group toc">
						<li class="list-group-item">
							<a href="functional-programming-magic.html">Functional programming magic</a>
						</li>
						<li class="list-group-item text-info">
							<a href="why-functional-programming.html">Why functional programming?</a>
						</li>
						<li class="list-group-item text-info">
							<i class="fa fa-star"></i> You don't need to check its presence
						</li>
					</ul>
					<p>
						Every Java programmer knows <code>Optional</code> type. If someone doesn't, shame on her/him. In this post I'll show you the power of <code>Optional</code>
						and will explain in details where does this power come from.
					</p>
					<h2>
						What is <code>Optional</code>?
					</h2>
					<p>
						First of all, <code>Optional</code> is a Monad. There will be more about Monads in another post but for the sake of this article I'm highlighting some
						characteristics.
					</p>
					<ul class="list-unstyled">
						<li>
							<i class="fa fa-check text-success"></i> Every Monad has factory method: <code>Optional.ofNullable()</code> or <code>Optional.of()</code>
						</li>
						<li>
							<i class="fa fa-check text-success"></i> Every Monad is a parameterized container: <code>Optional&lt;T&gt;</code>
						</li>
						<li>
							<i class="fa fa-check text-success"></i> Every Monad has a mapping method taking function accepting monad's type and returning Monad: <code
								class="text-nowrap">Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code>
						</li>
						<li>
							<i class="fa fa-check text-success"></i> Monads are immutable
						</li>
						<li>
							<i class="fa fa-check text-success"></i> Finally and last but not least Monad is a Monad only if it obeys three laws: <em>Left identity</em>, <em>Right
								identity</em>, <em>Associativity</em>. You must take it on faith now, <code>Optional</code> obeys all of them.
						</li>
					</ul>
					<p>
						<code>Optional</code> is a Monad indicating whether it holds some value or is empty. It is very useful replacement of <code>null</code> and we should
						avoid <code>nulls</code> at all costs because <code>null</code> is a huge code smell. There is not enough place here to express how smelly it is but we
						can Google it: <a href="https://www.google.com/search?q=java+null+criticism">java null criticism</a>,
					</p>
					<h2>
						Why you are using <code>Optional</code> wrong?
					</h2>
					<p>Is it happening to you more often than very rarely to write code like this?</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/CalculateSalary.java" data-format="lines 26,37"></code></pre>
					<p>
						If it does, please stop doing this, you are hurting all <em>Monads</em>. The fact that <code>Optional.isPresent()</code> is available doesn't mean that we
						should use it except exceptional situations. If we would like to follow monadic conventions, above code should look like this:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/CalculateSalaryValid.java"
						data-format="lines 26,29"></code></pre>
					<p>
						These code snippets lengths difference is striking, isn't it? The <code>calculateSalary</code> method signature is changed too, the return type is <code>Optional&lt;BigDecimal&gt;</code>
						now. It might seem to be minor difference but is quite significant. We don't have to document internal implementation behavior of returning <code>null</code>
						in case of not found employee, we expressed it by method's signature. We inverted the control making caller's code to decide what to do in such case,
						whether pass some other <code>Optional</code> further or maybe throw an exception. We just don't care here and this is good.
					</p>
					<p class="note">
						Don't consume <code>Optional</code> to early, let it flow through your code for the sake of clarity and safety.
					</p>
					<h3>Map and filter it</h3>
					<p>
						Next case are the heavily underused <code>map</code> and <code>filter</code> methods. Let's say we have string values stored in the map and expose it via
						some service class. Additional features provided by this class is the validation of the keys used to obtain values and some method used to decorate
						returned values. This is traditional example implementation.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DecoratingStore1.java"></code></pre>
					<p>
						This series of <code>if</code> statements can be easily replaced with <code>Optional</code>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DecoratingStore2.java"></code></pre>
					<p>
						We can go further and get rid of blank key check before <code>Optional</code> creation.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DecoratingStore3.java"></code></pre>
					<p>
						We are allowed to use <code>cache::get</code> in line <span class="badge badge-secondary">10</span> because <code>Optional.map()</code> expects <code
							class="text-nowrap">Function&lt;? super String,? extends String&gt;</code> there. It means function accepting any superclass of <code>String</code> and
						returning any subclass of <code>String</code>. Our <code>cache.get()</code> method reference with signature <code>Function&lt;Object,String&gt;</code>
						fits there.
					</p>
					<p>I personally find it much more convenient and descriptive to apply filters and transformations in this way. If you don't, maybe next example will be
						more convincing.</p>
					<p>Our task it to write method parsing text provided by user to percent format. To make things more complicated, users are from country using comma as
						decimal separator. This is simple implementation.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Parser1.java"></code></pre>
					<p>
						And this is equivalent implementation using <code>Optional</code>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Parser2.java"></code></pre>
					<p>
						One might say that this is semantically the same code, only syntax vary. Well, that's true, but there is one difference you might not spot. In first
						example we did several intermediate assignments in lines <span class="badge badge-secondary">7</span>, <span class="badge badge-secondary">9</span> and <span
							class="badge badge-secondary">11</span> to increase readability. It required additional mental work to think about clean variables names. When we perform
						series of transformations with <code>Optional.map()</code> we can avoid this job.
					</p>
					<p>
						Additional thing to point out is the weird exception thrown in line <span class="badge badge-secondary">19</span>. This is dead code actually so it
						doesn't matter what exception is declared to be thrown, it will never be thrown anyway. It will never be thrown because any problematic value will cause <code>NumberFormatException</code>
						in line <span class="badge badge-secondary">11</span>. It doesn't look good and would trigger questions and discussions. The reason is impure functions
						usage and bad API design. The impure function is <code>BigDecimal</code> constructor. It throws <code>NumberFormatException</code> in case of non number
						string provided as an argument. Pure functions always return value and never throw exceptions. In previous examples we also saw the rule applied: <em>Don't
							consume <code>Optional</code> to early
						</em>. Let's change the parser code to return <code>Optional</code> and use pure functions.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Parser3.java"></code></pre>
					<p>
						This time we use pure <code>createBigDecimal(String str)</code> function to create <code>Optional&lt;BigDecimal&gt;</code> from <code>String</code>. It
						will return <code>Optional.empty()</code> in case of invalid number representation. To handle nested <code>Optional</code> mapping, we use <code>Optional.flatMap()</code>
						in line <span class="badge badge-secondary">19</span>, otherwise the type returned by expression would be <code>Optional&lt;Optional&lt;String&gt;&gt;</code>.
						One thing to notice is that we don't know the reason why our <code>parsePercent</code> function returned empty <code>Optional</code>: because provided
						argument is <code>null</code>, blank string or invalid number representation? The calling code knows only whether there is some value or there is now
						value returned. There is handy way of handling such cases with ... of course another Monad named <code>Try</code>. There will be another post about <code>Try</code>
						Monad but here below is the same code using <code>Try</code> from <a href="https://www.vavr.io">Vavr</a> library.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Parser4.java"></code></pre>
					<p>
						The <code>Try</code> and <code>Optional</code> based code similarities are really striking, so much that it's easy to overlook the differences by just
						reading the code. Furtunately, the compiler will spot the difference. The caller code will not differ much as well. Used <code>Try</code> implementation
						provides bunch of methods very similar to those supplied by <code>Optional</code>, like: <code>orElse</code>, <code>getOrElseGet</code> or <code>getOrElseThrow</code>.
						We can even convert the <code>Try</code> to <code>Optional</code> with <code>toJavaOptional()</code> method if we don't care about error details.
					</p>
					<p class="note">
						This is the true power of Monads: we use all of them in the same way. If we know how to use <code>Optional</code>, we know how to use other Monads.
					</p>
					<h3>Handling missing nested values</h3>
					<p>
						To let you feel what I mean by deep nested missing values, I'd like to recall you old Java <em>XML W3C DOM API</em>. I find it most tedious to work with,
						because methods it provides, very often return <code>null</code> values. Additionally, XML's Document Object Model is the tree of nodes that can be really
						deep.
					</p>
					<p>Let's imagine that we have users database stored in XML file like this one:</p>
					<pre><code class="language-xml" data-src="../src/test/resources/users.xml"></code></pre>
					<p>As we can see, some users have address specified and some do not. To get user's street from address, we have to access it via quite long path:</p>
					<ul>
						<li>
							find node named <code>user</code>
						</li>
						<li>
							check whether child node <code>id</code> has expected text content
						</li>
						<li>
							get <code>location</code> child node
						</li>
						<li>
							get <code>address</code> child node if <code>location</code> is present
						</li>
						<li>
							get <code>street</code> child node if <code>address</code> is present
						</li>
					</ul>
					<p>
						I'll let you you imagine how boring and error prone native DOM API use would be. To mitigate this, we created several functions operating on <code>org.w3c.dom.Node</code>
						and using <code>Optional</code> as return value heavily.
					</p>
					<p>
						First, we need the easy way to iterate over child nodes. Unfortunately, <code>NodeList</code> returned by <code>Node.getChildNodes()</code> isn't <code>Iterable</code>.
						Lets' create our own implementation.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DomCombinators.java" data-format="lines 17,36"></code></pre>
					<p>
						If we have <code>Iterator</code>, we can use <code>Stream</code> created from it. This is function creating <code>Stream</code> from <code>NodeList</code>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DomCombinators.java" data-format="lines 37,48"></code></pre>
					<p>Next, we need some predicates to check various node properties.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DomCombinators.java" data-format="lines 49,71"></code></pre>
					<p>
						As we can see, there is <code>Optional</code> used all the time. This is due to the fact, that <code>Node</code> methods can return <code>null</code>
						depending on <code>Node</code> type. For example, <code>getNodeName()</code> or <code>getAttributes()</code> methods called on text node always return <code>null</code>.
						We create <code>Optional</code> using <code>of()</code> factory method because we don't accept <code>null</code> in predicates. In this way, we will fail
						fast with <code>NullPointerException</code>.
					</p>
					<p>Then we need functions finding nodes. Here they are.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DomCombinators.java" data-format="lines 72,81"></code></pre>
					<p>
						Finally, if we have node finding functions, we can easily create additional useful predicate checking whether given <code>Node</code> has child matching
						given condition.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/DomCombinators.java" data-format="lines 82,86"></code></pre>
					<p>Let's see our toys in action.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p3/UsersXmlTest.java" data-format="lines 41,52"></code></pre>
					<p>
						This code is totally safe (unless we left some bugs) and way easier to write and comprehend. We created custom <code>Node</code> <code>Predicate</code>
						from primitive ones for convenience and used in line <span class="badge badge-secondary">3</span>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p3/UsersXmlTest.java" data-format="lines 35,39"></code></pre>
					<p>
						This predicate checks, whether given node name is <code>user</code> and has child node named <code>id</code> with text content equal given <code>id</code>
						argument.
					</p>
					<p>
						Below test code is identical to previous on, only assertion differs because we don't expect <em>Mary Jane</em> (having id <em>2</em>) to have address
						specified at all.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p3/UsersXmlTest.java" data-format="lines 54,64"></code></pre>
					<p>What if we ask about non existing user? No problem.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p3/UsersXmlTest.java" data-format="lines 66,76"></code></pre>
					<p>
						There is no user with id <em>3</em> and the test doesn't fail.
					</p>
					<p>And what about using attributes not present in our XML file? No issues at all.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p3/UsersXmlTest.java" data-format="lines 78,89"></code></pre>
					<p>
						There is no <code>user</code> node with attribute <code>name</code> and the test passes.
					</p>
					<p>
						As we can see, by writing less then 100 lines of code using <code>Optional</code> heavily we made our life with <em>XML DOM API</em> easier and safer.
					</p>
					<h3>Eager and lazy alternative value</h3>
					<p>
						One of the frequent usages of <code>Optional</code> is to get alternative value in case of empty <code>Optional</code>. We do this via <code>orElse(T
							other)</code> or <code>orElseGet(Supplier&lt;? extends T&gt; other)</code> method. It's common mistake to use <code>orElse</code> while <code>orElseGet</code>
						should be used. The difference between these methods is that <code>orElseGet</code> takes <code>Supplier</code>, so actual alternative value is evaluated
						lazy, only if is needed meaning when <code>Optional</code> is empty. Java evaluates methods arguments before method body execution, we call it <em>eager
							evaluation</em>. Improper selection of alternative value provider may result in unexpected behaviors, like in below example.
					</p>
					<p>
						Let's say, we have repository interface and implementation backed up by some persistence technology. We express missing lookup by primary identifier by
						returning <code>Optional</code> from appropriate method.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Repository.java"></code></pre>
					<p>
						<code>getDefault</code> in line <span class="badge badge-secondary">5</span> returns the <code>Entity</code> by hardcoded <code>id</code> value and can be
						used if the one we were looked for was not found. It also prints debug message for presentation purpose. Here below is simple test showing the difference
						between eager and lazy evaluation of <code>Optional</code> alternative value.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p3/RepositoryTest.java"></code></pre>
					<p>
						<code>orElseGet</code> alternative value provider works in this way because it expects <code>Supplier</code> implementation. <code>Supplier</code> is the
						functional interface with single abstract method <code>T get()</code>. This is all we need to obtain default value, just call <code>get()</code> and
						return its result. This is exactly what <code>orElseGet</code> method does. Without calling <code>Supplier.get()</code> nothing happens. On the other
						side, <code>orElse</code> expects default value which is evaluated before execution of our code using <code>Optional</code>. If we want to return simple
						default value, like <code>BigDecimal.ZERO</code>, <code>Optional.orElse()</code> is perfectly legitimate.
					</p>
					<p class="note">
						Whenever additional operations are needed to provide default value in case of empty <code>Optional</code>, use <code>orElseGet</code>. If the default
						value is just simple object or constant, use <code>orElse</code>.
					</p>
					<h2>
						Anatomy of <code>Optional</code>
					</h2>
					<p>
						If you think that behind <code>Optional</code>'s powers stays some sophisticated code ... you are wrong. The concept and implementation is actually very
						easy. The best way to see what is happening under the hood is to implement our version of <code>Optional</code>. Let's name it <code>Maybe</code> to
						distinguish it from Java's <code>Optional</code> and Scala's <code>Option</code>.
					</p>
					<p>
						Our <code>Maybe</code> is the generic container, so it has to be parameterized.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/m1/Maybe.java"></code></pre>
					<p>
						If we think about very nature of <code>Maybe</code> it's just <em>either something or nothing</em>. We can easily design it as abstract class with only
						two implementations: <code>Just</code> and <code>Nothing</code>. We don't want to allow any other implementations to exist, so let's make <code>Maybe</code>,
						<code>Just</code> and <code>Nothing</code> constructors private. <code>Just</code> and <code>Nothing</code> will be static and final inner classes of <code>Maybe</code>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/m2/Maybe.java"></code></pre>
					<p>
						<code>Just</code> should hold some value, let's add the value placeholder to it.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/m3/Maybe.java"></code></pre>
					<p>
						There is only one and only one <code>Nothing</code>, we can create singleton for it.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/m4/Maybe.java"></code></pre>
					<p>
						If you wonder why <code>NOTHING</code> singleton is of unbounded wildcard type, the answer is simple: <code>Nothing</code> holds no value, it's type is
						meaningless and can be discarded.
					</p>
					<p>
						Next, we need to have the ways to create <code>Just</code> and <code>Nothing</code> instances. We can't just construct them, because their constructors
						are private. Let's write appropriate factory methods in <code>Maybe</code>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 38,47"></code></pre>
					<p>
						By factoring <code>Nothing</code> we always return our singleton instance <code>NOTHING</code>. We do cast it to <code>Maybe&lt;A&gt;</code> to avoid
						unnecessary unchecked cast warnings. Remember? <code>Nothing</code> holds no value and has no type actually, it's safe to cast it to <code>Maybe</code> of
						any <code>A</code>. <code>Just</code> on the other hand must hold the value, <code>null</code> is not acceptable, hence we validate <code>just</code>
						factory method argument against <code>null</code> references in line <span class="badge badge-secondary">7</span>.
					</p>
					<p>
						We would like to create <code>Maybe</code> without knowing if it's nothing or something too. Let's craft the method doing so.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 49,55"></code></pre>
					<p>This is what we have so far.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/m5/Maybe.java"></code></pre>
					<p>
						We may have a value in <code>Just</code> but we don't know how to check it. Let's add <code>Maybe.isPresent()</code> abstract method and implementations.
						Obviously, implementation will be simple but completely different.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 16,16"></code></pre>
					<p>
						This is <code>Just</code>:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 106,109"></code></pre>
					<p>
						And this is <code>Nothing</code>:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 62,65"></code></pre>
					<p>
						Let's quickly go through value accessors declaration in <code>Maybe</code>, they are not very interesting anyway.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 18,22"></code></pre>
					<p>
						These are <code>Just</code> implementations:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 111,124"></code></pre>
					<p>
						And these are taken from <code>Nothing</code>:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 67,80"></code></pre>
					<p>
						We do completely opposite things in <code>Just</code> and <code>Nothing</code> respectively. This kind of symmetry is often present in functional
						programming where Monads were born.
					</p>
					<p>
						Finally the most important methods: <code>flatMap</code> and <code>map</code>. If you wonder why <code>flatMap</code> is in the first place ... the reason
						is simple, <code>map</code> can be implemented using <code>flatMap</code>.
					</p>
					<p>
						Let's start with <code>map</code> because it's easier to comprehend. Its signature is as follows: <code class="text-nowrap">Maybe&lt;B&gt;
							map(Function&lt;? super A,? extends B&gt; f)</code>. <code>f</code> argument is named after <code>Function</code>. What this method does is: <em>it takes
							given mapping function and returns new <code>Maybe</code> containing result of this function applied to <code>Maybe</code> value
						</em>. <code>Nothing</code> implementation is simple, there is no value to apply given function to, we have only one choice, return <code>Nothing</code>.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 87,90"></code></pre>
					<p>
						<code>Just.map()</code> implementation is very straightforward too:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 131,134"></code></pre>
					<p>
						<code>flatMap</code> behavior is harder to explain and easier to write: <em>take <code>Maybe</code> with some value in it and apply mapping function
							returning other <code>Maybe</code> to original <code>Maybe</code> value.
						</em> <code>Nothing.flatMap()</code> returns <code>Nothing</code>, no surprises here.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 92,95"></code></pre>
					<p>
						<code>Just.flatMap()</code> simply returns the result of given function applied to wrapped value.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 136,139"></code></pre>
					<p>
						<code>flatMap</code> is the feature making <code>Maybe</code> a Monad, actually <code>map</code> is redundant because can be implemented using <code>flatMap</code>.
						It is usually implemented separately for performance reasons.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 30,32"></code></pre>
					<p>
						<code>mapViaFlatMap</code> is a method implemented in our abstract <code>Maybe</code> class. Presented above code is very functional. We can read is as: <em>take
							<code>f</code> function, compose it with <code>Maybe::just</code>, the composed function is <code>just(f(v))</code> with signature <code
							class="text-nowrap">Function&lt;? super A,Maybe&lt;B&gt;&gt;</code> and pass it to <code>flatMap</code>.
						</em> We can also implement it using lambda expression if we find it easier to grasp:
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java" data-format="lines 34,36"></code></pre>
					<p>
						If you don't know what function composition is, you may find my post <a href="functional-programming-magic.html">Functional programming magic</a> quite
						helpful. If you would like to see full <code>Maybe</code> source, <a class="ans" data-toggle="collapse" href="#maybe">click here</a>. You will find side
						effects performing <code>ifPresentOrElse</code> method there.
					</p>
					<pre class="collapse line-numbers" id="maybe"><code class="language-java" data-src="../src/main/java/tech/daniellas/p3/Maybe.java"></code></pre>
					<p>
						That's it, about 100 lines of code and we have fully functional <code>Optional</code> replacement. We reinvented the wheel, there are plenty
						implementations available but our understanding of <code>Optional</code> is much better thanks to this exercise.
					</p>
					<h2>Summary</h2>
					<p>
						We know how to use <code>Optional</code>. We know how simple and easy to implement concept it is. This is always like this: <em>great power lies in
							simplicity</em>. I personally can't imagine my life without some kind of <code>Optional</code> in my programming toolkit and I hope that after reading my post
						you will not be able to do so either.
					</p>
				</div>
			</div>
		</div>
	</article>
	<hr>
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-lg-8 col-md-10 mx-auto">
					<ul class="list-inline text-center">
						<li class="list-inline-item">
							<a href="https://www.linkedin.com/in/daniel-las" target="_blank"> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i
									class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
							</span>
							</a>
						</li>
					</ul>
					<p class="copyright text-muted">
						Copyright &copy; Daniel Łaś 2019, Look and feel forked from <a href="https://startbootstrap.com/template-overviews/clean-blog/" target="blank">Clean
							Blog</a>
					</p>
				</div>
			</div>
		</div>
	</footer>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
	<div class="alert text-center cookiealert">
		We use cookies to ensure you get the best experience on our site.
		<button class="btn btn-primary btn-sm acceptcookies">I agree</button>
	</div>
	<script src="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.js"></script>
	<script src="../js/clean-blog.min.js"></script>
	<script src="../js/examples.1.0.0.min.js"></script>
</body>
</html>
