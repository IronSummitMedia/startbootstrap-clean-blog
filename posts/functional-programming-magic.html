<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Functional Programming, Java">
<meta name="author" content="Daniel Łaś">
<title>Daniel Łaś Tech Blog</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
<link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet'
	type='text/css'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.css">
<link href="../css/clean-blog.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js" data-manual></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12045869-7"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'UA-12045869-7');
</script>
</head>
<body>
	<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
		<div class="container">
			<a class="navbar-brand" href="../index.html">Home</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive"
				aria-expanded="false" aria-label="Toggle navigation">
				Menu <i class="fas fa-bars"></i>
			</button>
			<div class="collapse navbar-collapse" id="navbarResponsive">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link" href="../index.html">Home</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../about.html">About</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../contact.html">Contact</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>
	<header class="masthead sm">
		<div class="overlay"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<div class="post-heading text-center">
						<h1>Functional programming is like magic</h1>
						<h2 class="subheading">Like every magic, it's difficult and not for everyone</h2>
					</div>
				</div>
			</div>
		</div>
	</header>
	<article>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<p>This is first part of pragmatic functional programming tutorial for Java developers. It's based on my experience taken from lessons of functional
						programming in Java I give at work.</p>
					<p class="text-center">
						<em>I hope you will enjoy it as much as I do teaching.</em>
					</p>
					<p>
						Functional programming is difficult. It's building blocks are simple but if you are regular Java developer you need to change your perspective and shift
						paradigm to learn it. It borrows a lot from <em>Category Theory</em>, developed own jargon difficult to grasp at the beginning, uses recursion and
						sophisticated data structures extensively.
					</p>
					<p>
						It's not for everyone because people think and solve problems in different ways. For some of us, it's natural to think about objects encapsulating some
						state and communicating with each other. Some of us prefer to think in terms of some data being passed through chain of transformations to get final
						desired result. Both ways are <em>Turing equivalent</em> (equally powerful), just like <em>Turing Machine</em> and <em>Lambda Calculus</em> computation
						models. Ultimately, functional programs are merely nice abstraction on top of fast <em>Turing machines</em>.
					</p>
					<p>So what's the point? Is it worth to learn at all? Yes, I believe it is. It adds several superpowers to our programming toolkit and I will show you
						what these powers are and how to use them.</p>
					<h2 class="section-heading">But what is functional programming?</h2>
					<p>This is not an easy question and answer usually depends on whom you ask. Here below you find basic concepts and techniques description.</p>
					<h3>Program with Pure Functions</h3>
					<p>This sounds reasonable, functional programming must have something to do with functions, right?</p>
					<p class="note">The very first step in learning functional programming is to model the problem solution in terms of pure functions.</p>
					<p>Instead of mutating objects like here:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/imp/Player.java"></code></pre>
					<p>Use pure functions to provide desired answers without object mutations:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/fun/Player.java"></code></pre>
					<p class="note">
						Here you saw first code examples and might miss <code>private</code> or <code>public</code> modifiers. I did it by purpose to make code shorter. I will
						often omit import declarations , getters and setters for the same reason.
					</p>
					<p>What makes function pure?</p>
					<ul>
						<li>Pure function takes some value and returns some value only</li>
						<li>Pure function is side effects free</li>
						<li>Pure function depends only on it's arguments</li>
						<li>Pure function returns the same result if applied to the same arguments, always</li>
					</ul>
					<p class="note">
						Please remember, we say <em>apply function to arguments</em> and not <em>apply arguments to function</em>.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Funcs.java" data-format="skip-class"></code></pre>
					<p>
						This is nice function, beautiful in it's purity and simplicity. It does only one thing. It takes <code>Integer</code> type argument and returns new <code>Integer</code>
						number. It doesn't change it's arguments. Actually it can't because <code>java.lang.Integer</code> is immutable. It is side effects free, meaning that no
						external state is modified, no external variables are assigned. It reads no external variable, all it needs are function's arguments. It is <code>static</code>
						method, what makes <code>this</code> reference not accessible inside body. It can be non static for your convenience, just don't access <code>this</code>
						in body.
					</p>
					<p>One might argue that it should be:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/FuncsFinal.java" data-format="skip-class"></code></pre>
					<p>
						The <code>final</code> modifier used in argument protects functions's code from assigning argument reference with new value:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/FuncsFinalFail.java" data-format="skip-class"></code></pre>
					<p>
						But I'm personally not very strict in using <code>final</code> modifiers in arguments declaration due to it's verbosity. Just keep your functions small
						and never ever use arguments reassignments, or use <code>final</code> modifiers and let Java compiler protect you from such smelly practices.
					</p>
					<p>
						<em>There are very important consequences of function purity.</em> To understand what function is doing, you only need to see it's body. To test it, you
						only need to invoke it and assert result. There are no surprises, no looking around your code to check whether external variable used by your function is
						modified by external code. And last but not least <em>Referential Transparency</em> - concept I will explain in next parts.
					</p>
					<p class="note">Whatever programming language you use, just follow pure functions rules to start programming functional way.</p>
					<h3>Higher order functions</h3>
					<p>Higher order functions is very simple yet powerful concept. It's just function taking another function as argument or function returning function.</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/hof/Player.java"></code></pre>
					<p>
						<code>hasAge</code> is a higher order function because it accepts <code>java.util.function.Predicate&lt;Integer&gt;</code> as it's argument. Predicate is
						a generic function taking given type argument and returning <code>boolean</code>.
					</p>
					<p>
						If you'd ask me if given programming language supports functional programming style, my answer would depend on it's capability of treating functions as <em>first
							class citizen</em>:
					</p>
					<ul>
						<li>can function be passed as an argument to other function</li>
						<li>can function be returned from function</li>
						<li>can function be assigned to variable or constant</li>
					</ul>
					<p class="note">
						If above conditions are met, you can program functional way. This is functional programming magic. You can build powerful abstractions using very simple
						concept of <em>higher order functions</em>
					</p>
					<h3>Currying and Partial Application</h3>
					<p>Currying and partial application are closely related and extremely useful techniques. We use them to manipulate existing functions and construct new
						functions from existing functions. It's very common and handy that we create new functions from available building blocks. Currying and partial
						application are conceptually similar to Object Oriented Programming and it's Design Patterns, where basic concepts are inheritance, polymorphism and
						composition. In OOP we use Design Patterns and in FP we use higher order functions, currying and partial application to construct our code abstractions.</p>
					<p>
						Let's look at currying first. The name of this technique is taken from <em>Haskel Curry</em>, American mathematician. The idea is based on the fact:
					</p>
					<p class="note">Every pure function accepting multiple arguments can be transformed to higher order function taking single argument and returning
						function taking single argument and returning function taking single argument and ... so on, depending on arguments number of function we curry.</p>
					<p>
						Actually, in some programming languages like <em>Haskel</em> we define our functions in curried form by default.
					</p>
					<p>This is simple example of currying:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Currying.java" data-format="skip-class"></code></pre>
					<p>
						Unfortunately there is no native support of currying in Java so curried form declaration: <code>Function&lt;Integer, Function&lt;Integer,
							Integer&gt;&gt;</code> looks weird and is difficult to read. Fortunately there are some mitigation techniques I'll show you later. Despite the lack of currying
						support, it's easy to write generic function transforming any <code>BiFunction</code> to curried form.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Curry.java" data-format="skip-class"></code></pre>
					<p>
						Our <code>curry</code> function is the nice example of higher order function. It takes function as an argument and returns function. You deserve warning
						now. This is how functional programming code often looks. Please try to understand what's going on in above and following examples and I promise, it will
						pay off in the near future.
					</p>
					<p>
						If you wonder how currying might be useful, let me show you one example. Many core Java 8 functions expect <code>Function</code> as it's only argument,
						like <code>map</code> in <code>Optional</code> or <code>Stream</code>.
					</p>
					<p>
						If we have some <code>BiFunction</code> we can curry it and pass to <code>Stream.map()</code> or <code>Optional.map()</code> functions without wrapping it
						with some private function or using lambda expression.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/CurryExamples.java" data-format="skip-class"></code></pre>
					<p>It's time to tackle partial application, but it's too late now. We already covered it. What we did in previous example was:</p>
					<ol>
						<li>
							we took available function <code>sum</code> accepting two arguments
						</li>
						<li>
							transformed it to different function by currying it, so we created <code>Function&lt;Integer,Function&lt;Integer,Integer&gt;&gt;</code>
						</li>
						<li>
							applied our function with value <code>1</code>
						</li>
						<li>
							and finally assigned produced <code>Function&lt;Integer,Integer&gt;</code> to constant
						</li>
					</ol>
					<p>
						Written code is as terse as <code>curry(sum).apply(1)</code>.
					</p>
					<p class="note">Partial application is the process of transforming multiple arguments function by applying it to less arguments then expected,producing
						function with arguments number decreased by arguments count we provided.</p>
					<p>Do you see the pattern? Whenever we see the pattern we abstract it. That's what we do as programmers. Since this post is about functional
						programming, lets abstract partial application into function.</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Partial.java" data-format="skip-class"></code></pre>
					<p>
						I wrote that currying and partial application are closely related because we can write <code>partial</code> function using <code>curry</code> function
						like in this code:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/PartialViaCurry.java" data-format="skip-class"></code></pre>
					<p>
						You saw the examples of functions transforming other functions like <code>curry</code> or <code>partial</code> and can feel a bit confused. Let me give
						you some exercises to let you practice and get better intuition in manipulating functions.
					</p>
					<p class="exc">
						Write function transforming any two arguments function into two arguments function with arguments reversed.
						<a class="ans" data-toggle="collapse" href="#reverse">Show answer</a>
					</p>
					<pre class="collapse" id="reverse"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Reverse.java" data-format="skip-class"></code></pre>
					<p class="exc">
						Write function currying any two arguments function from the right side.
						<a class="ans" data-toggle="collapse" href="#curryRight">Show answer</a>
					</p>
					<pre class="collapse" id="curryRight"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/CurryRight.java"
						data-format="skip-class"></code></pre>
					<p class="exc">
						Write function currying any two arguments function from the right using <code>reverse</code> function.
						<a class="ans" data-toggle="collapse" href="#curryRightReverse">Show answer</a>
					</p>
					<pre class="collapse" id="curryRightReverse"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/CurryRightViaReverse.java"
						data-format="skip-class"></code></pre>
					<h3>Functions composition</h3>
					<p>Well, here comes my favorite feature of functions. They do compose really well.</p>
					<blockquote>
						<p>And how do we solve problems? We decompose bigger problems into smaller problems. If the smaller problems are still too big, we decompose them
							further, and so on. Finally, we write code that solves all the small problems. And then comes the essence of programming: we compose those pieces of code
							to create solutions to larger problems. Decomposition wouldn’t make sense if we weren’t able to put the pieces back together.</p>
						<p>This process of hierarchical decomposition and recomposition is not imposed on us by computers. It reflects the limitations of the human mind. Our
							brains can only deal with a small number of concepts at a time.</p>
						<a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/" target="_blank">Category Theory for Programmers, Bartosz
							Milewski</a>
					</blockquote>
					<p>I couldn't agree more with above statements. We do decompose and compose objects using object oriented languages or procedures when procedural
						languages come to play. Ability to compose is the very nature of pure functions, they just accept value ant return value, so we can take any number of
						functions and chain them in the way, that the result of previous function becomes an input of next function. Just like in following example:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition.java" data-format="skip-class"></code></pre>
					<p>
						I agree, it's not very useful. Lets look at more realistic example. We have simple task: write function accepting user provided string and convert it to
						percent format if possible. In case of non-number input, just return <em>0 %</em>.
					</p>
					<p>This is our first attempt:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition1.java" data-format="skip-class"></code></pre>
					<p>
						It looks fine at first glance, but there are some issues in it. It does more than one thing: parses <code>String</code> to <code>BigDecimal</code>,
						multiplies result by 100, appends ' %' suffix, handle errors. All those actions are hidden inside function body and can't be reused or tested separately.
					</p>
					<p>Let's decompose it into smaller chunks and compose back to create our final function.</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition2.java"></code></pre>
					<p>
						Well, we have small functions but composing them is the real pain, isn't it? What can we do about this? We can use Java 8 <code>java.util.function.Function</code>
						and partial application to make them easier to use.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition3.java"></code></pre>
					<p>I particularly like expressiveness of our functions applications in last lines. It's like some story told:</p>
					<ul>
						<li>
							apply <code>parse</code> safely
						</li>
						<li>then multiply by 100</li>
						<li>then append ' %' string</li>
						<li>call with '0.5' argument</li>
					</ul>
					<p>
						Let me explain the magic happening in last lines. We use <code>andThen</code> default method of <code>java.util.function.Function</code> interface. This
						is commented piece of this interface source code:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Function.java"></code></pre>
					<p>
						Whenever we need to apply multiple functions (let's say three functions named <em>f</em>, <em>g</em>, <em>h</em>) one after another like in this
						pseudocode <code>f(g(h(X x)))</code> , where <code>x</code> is argument of type <code>X</code>, we can use <code>andThen</code> higher order function like
						here: <code>h.andThen(g).andThen(f).apply(x)</code>.
					</p>
					<p>
						<code>h</code> function's result becomes <code>g</code> function's argument, and <code>g</code> function's result becomes <code>f</code> function's
						argument.
					</p>
					<p>
						We can apply multiple functions in opposite direction using <code>compose</code> like this: <code>h(g(f(X x)))</code>. Corresponding code would be: <code>h.compose(g).compose(f)</code>.
					</p>
					<p>
						<code>f</code> function's result becomes <code>g</code> function's argument, and <code>g</code> function's result becomes <code>h</code> function's
						argument. This is our tasks functions composed using <code>compose</code>:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition4.java"></code></pre>
					<p>Let's get back to our task. Although the way we call our functions looks better (of course only if we get used to this notation), we had to write
						much more code compared to first version. Fortunately, there is the light ...</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition5.java"></code></pre>
					<p>We didn't have to create our composing functions at the expense of readability. You might ask which way to go then? I would argue that having small
						generic functions that can be reused to compose other functions is the good approach. There are plenty of reusable functions available in Java Core API or
						external libraries, they are thoroughly tested and can save a lot of our time.</p>
					<h3>Identity</h3>
					<p>TBC</p>
					<h3>Side effects separation and explicit state mutation</h3>
					<p>TBC</p>
					<h2>What's next?</h2>
					<p>In next post you will read why it's worth to learn functional programming.</p>
				</div>
			</div>
		</div>
	</article>
	<hr>
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-lg-8 col-md-10 mx-auto">
					<ul class="list-inline text-center">
						<li class="list-inline-item">
							<a href="https://www.linkedin.com/in/daniel-las" target="_blank">
								<span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
								</span>
							</a>
						</li>
					</ul>
					<p class="copyright text-muted">
						Copyright &copy; Daniel Łaś 2019, Look and feel forked from
						<a href="https://startbootstrap.com/template-overviews/clean-blog/" target="blank">Clean Blog</a>
					</p>
				</div>
			</div>
		</div>
	</footer>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
	<div class="alert text-center cookiealert">
		We use cookies to ensure you get the best experience on our site.
		<button class="btn btn-primary btn-sm acceptcookies">I agree</button>
	</div>
	<script src="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.js"></script>
	<script src="../js/clean-blog.min.js"></script>
	<script src="../js/examples.min.js"></script>
</body>
</html>
