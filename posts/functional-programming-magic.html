<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Functional Programming, Java">
<meta name="author" content="Daniel Łaś">
<title>Daniel Łaś Tech Blog</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
<link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet'
	type='text/css'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.css">
<link href="../css/clean-blog.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js" data-manual></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12045869-7"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'UA-12045869-7');
</script>
</head>
<body>
	<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
		<div class="container">
			<a class="navbar-brand" href="../index.html">Home</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive"
				aria-expanded="false" aria-label="Toggle navigation">
				Menu <i class="fas fa-bars"></i>
			</button>
			<div class="collapse navbar-collapse" id="navbarResponsive">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link" href="../index.html">Home</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../about.html">About</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../contact.html">Contact</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>
	<header class="masthead sm">
		<div class="overlay"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<div class="post-heading text-center">
						<h1>Functional programming is like magic</h1>
						<h2 class="subheading">Like every magic, it's difficult and not for everyone</h2>
					</div>
				</div>
			</div>
		</div>
	</header>
	<article>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<p>This is first part of pragmatic functional programming tutorial for Java developers. It's based on my experience taken from lessons of functional
						programming in Java I give at work.</p>
					<p class="text-center">
						<em>I hope you will enjoy it as much as I do teaching.</em>
					</p>
					<p>
						Functional programming is difficult. It's building blocks are simple but if you are regular Java developer you need to change your perspective and shift
						paradigm to learn it. It borrows a lot from <em>Category Theory</em>, developed own jargon difficult to grasp at the beginning, uses recursion and
						sophisticated data structures extensively.
					</p>
					<p>
						It's not for everyone because people think and solve problems in different ways. For some of us, it's natural to think about objects encapsulating some
						state and communicating with each other. Some of us prefer to think in terms of some data being passed through chain of transformations to get final
						desired result. Both ways are <em>Turing equivalent</em> (equally powerful), just like <em>Turing Machine</em> and <em>Lambda Calculus</em> computation
						models. Ultimately, functional programs are merely nice abstraction on top of fast <em>Turing machines</em>.
					</p>
					<p>So what's the point? Is it worth to learn at all? Yes, I believe it is. It adds several superpowers to our programming toolkit and I will show you
						what these powers are and how to use them.</p>
					<h2 class="section-heading">But what is functional programming?</h2>
					<p>This is not an easy question and answer usually depends on whom you ask. Here below you find basic concepts and techniques description.</p>
					<h3>Program with Pure Functions</h3>
					<p>This sounds reasonable, functional programming must have something to do with functions, right?</p>
					<p class="note">The very first step in learning functional programming is to model the problem solution in terms of pure functions.</p>
					<p>Instead of mutating objects like here:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/imp/Player.java"></code></pre>
					<p>Use pure functions to provide desired answers without object mutations:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/fun/Player.java"></code></pre>
					<p class="note">
						Here you saw first code examples and might miss <code>private</code> or <code>public</code> modifiers. I did it by purpose to make code shorter. I will
						often omit import declarations , getters and setters, generic wildcards declarations (<code>&lt;? super A&gt;</code> and <code>&lt;? extends A&gt;</code>)
						for the same reason. <em>Please read the code carefully as I will put many explanations there</em>
					</p>
					<p>What makes function pure?</p>
					<ul>
						<li>Pure function takes some value and returns some value only</li>
						<li>Pure function is side effects free</li>
						<li>Pure function depends only on it's arguments</li>
						<li>Pure function returns the same result if applied to the same arguments, always</li>
					</ul>
					<p class="note">
						Please remember, we say <em>apply function to arguments</em> and not <em>apply arguments to function</em>.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Funcs.java" data-format="skip-class"></code></pre>
					<p>
						This is nice function, beautiful in it's purity and simplicity. It does only one thing. It takes <code>Integer</code> type argument and returns new <code>Integer</code>
						number. It doesn't change it's arguments. Actually it can't because <code>java.lang.Integer</code> is immutable. It is side effects free, meaning that no
						external state is modified, no external variables are assigned. It reads no external variable, all it needs are function's arguments. It is <code>static</code>
						method, what makes <code>this</code> reference not accessible inside body. It can be non static for your convenience, just don't access <code>this</code>
						in body.
					</p>
					<p>One might argue that it should be:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/FuncsFinal.java" data-format="skip-class"></code></pre>
					<p>
						The <code>final</code> modifier used in argument protects functions's code from assigning argument reference with new value:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/FuncsFinalFail.java" data-format="skip-class"></code></pre>
					<p>
						But I'm personally not very strict in using <code>final</code> modifiers in arguments declaration due to it's verbosity. Just keep your functions small
						and never ever use arguments reassignments, or use <code>final</code> modifiers and let Java compiler protect you from such smelly practices.
					</p>
					<p>
						<em>There are very important consequences of function purity.</em> To understand what function is doing, you only need to see it's body. To test it, you
						only need to invoke it and assert result. There are no surprises, no looking around your code to check whether external variable used by your function is
						modified by external code. And last but not least <em>Referential Transparency</em> - concept I will explain in next parts.
					</p>
					<p class="note">Whatever programming language you use, just follow pure functions rules to start programming functional way.</p>
					<h3>Higher order functions</h3>
					<p>Higher order functions is very simple yet powerful concept. It's just function taking another function as argument or function returning function.</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/hof/Player.java"></code></pre>
					<p>
						<code>hasAge</code> is a higher order function because it accepts <code>java.util.function.Predicate&lt;Integer&gt;</code> as it's argument. Predicate is
						a generic function taking given type argument and returning <code>boolean</code>.
					</p>
					<p>
						If you'd ask me if given programming language supports functional programming style, my answer would depend on it's capability of treating functions as <em>first
							class citizen</em>:
					</p>
					<ul>
						<li>can function be passed as an argument to other function</li>
						<li>can function be returned from function</li>
						<li>can function be assigned to variable or constant</li>
					</ul>
					<p class="note">
						If above conditions are met, you can program functional way. This is functional programming magic. You can build powerful abstractions using very simple
						concept of <em>higher order functions</em>
					</p>
					<h3>Currying and Partial Application</h3>
					<p>Currying and partial application are closely related and extremely useful techniques. We use them to manipulate existing functions and construct new
						functions from existing functions. It's very common and handy that we create new functions from available building blocks. Currying and partial
						application are conceptually similar to Object Oriented Programming and it's Design Patterns, where basic concepts are inheritance, polymorphism and
						composition. In OOP we use Design Patterns and in FP we use higher order functions, currying and partial application to construct our code abstractions.</p>
					<p>
						Let's look at currying first. The name of this technique is taken from <em>Haskel Curry</em>, American mathematician. The idea is based on the fact:
					</p>
					<p class="note">Every pure function accepting multiple arguments can be transformed to higher order function taking single argument and returning
						function taking single argument and returning function taking single argument and ... so on, depending on arguments number of function we curry.</p>
					<p>
						Actually, in some programming languages like <em>Haskel</em> we define our functions in curried form by default.
					</p>
					<p>This is simple example of currying:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Currying.java" data-format="skip-class"></code></pre>
					<p class="note">
						This <code class="text-nowrap">a -> b -> = a + b</code> line is just lambda expression equivalent to <span><code class="text-nowrap">Function&lt;A,
								Function&lt;B, C&gt;&gt;</code></span>. We can nest any number of <code>-></code> in lambdas, this is perfectly legitimate syntax.
					</p>
					<p>
						Unfortunately there is no native support of currying in Java so curried form declaration: <code>Function&lt;Integer, Function&lt;Integer,
							Integer&gt;&gt;</code> looks weird and is difficult to read. Fortunately there are some mitigation techniques I'll show you later. Despite the lack of currying
						support, it's easy to write generic function transforming any <code>BiFunction</code> to curried form.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Curry.java" data-format="skip-class"></code></pre>
					<p>
						Our <code>curry</code> function is the nice example of higher order function. It takes function as an argument and returns function. You deserve warning
						now. This is how functional programming code often looks. Please try to understand what's going on in above and following examples and I promise, it will
						pay off in the near future.
					</p>
					<p>
						If you wonder how currying might be useful, let me show you one example. Many core Java 8 functions expect <code>Function</code> as it's only argument,
						like <code>map</code> in <code>Optional</code> or <code>Stream</code>.
					</p>
					<p>
						If we have some <code>BiFunction</code> we can curry it and pass to <code>Stream.map()</code> or <code>Optional.map()</code> functions without wrapping it
						with some private function or using lambda expression.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/CurryExamples.java" data-format="skip-class"></code></pre>
					<p>It's time to tackle partial application, but it's too late now. We already covered it. What we did in previous example was:</p>
					<ol>
						<li>
							we took available function <code>sum</code> accepting two arguments
						</li>
						<li>
							transformed it to different function by currying it, so we created <code>Function&lt;Integer,Function&lt;Integer,Integer&gt;&gt;</code>
						</li>
						<li>
							applied our function with value <code>1</code>
						</li>
						<li>
							and finally assigned produced <code>Function&lt;Integer,Integer&gt;</code> to constant
						</li>
					</ol>
					<p>
						Written code is as terse as <code>curry(sum).apply(1)</code>.
					</p>
					<p class="note">Partial application is the process of transforming multiple arguments function by applying it to less arguments then expected,producing
						function with arguments number decreased by arguments count we provided.</p>
					<p>
						Lets abstract partial application of any <code>BiFunction</code> into generic function:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Partial.java" data-format="skip-class"></code></pre>
					<p>
						I wrote that currying and partial application are closely related because we can write <code>partial</code> function using <code>curry</code> function
						like in this code:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/PartialViaCurry.java" data-format="skip-class"></code></pre>
					<p>
						You saw the examples of functions transforming other functions like <code>curry</code> or <code>partial</code> and can feel a bit confused. Let me give
						you some exercises to let you practice and get better intuition in manipulating functions.
					</p>
					<p class="exc">
						Write function transforming any two arguments function into two arguments function with arguments reversed.
						<a class="ans" data-toggle="collapse" href="#reverse">Show answer</a>
					</p>
					<pre class="collapse" id="reverse"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Reverse.java" data-format="skip-class"></code></pre>
					<p class="exc">
						Write function currying any two arguments function from the right side.
						<a class="ans" data-toggle="collapse" href="#curryRight">Show answer</a>
					</p>
					<pre class="collapse" id="curryRight"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/CurryRight.java"
						data-format="skip-class"></code></pre>
					<p class="exc">
						Write function currying any two arguments function from the right using <code>reverse</code> function.
						<a class="ans" data-toggle="collapse" href="#curryRightReverse">Show answer</a>
					</p>
					<pre class="collapse" id="curryRightReverse"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/CurryRightViaReverse.java"
						data-format="skip-class"></code></pre>
					<h3>Functions composition</h3>
					<p>Well, here comes my favorite feature of functions. They do compose really well.</p>
					<blockquote>
						<p>And how do we solve problems? We decompose bigger problems into smaller problems. If the smaller problems are still too big, we decompose them
							further, and so on. Finally, we write code that solves all the small problems. And then comes the essence of programming: we compose those pieces of code
							to create solutions to larger problems. Decomposition wouldn’t make sense if we weren’t able to put the pieces back together.</p>
						<p>This process of hierarchical decomposition and recomposition is not imposed on us by computers. It reflects the limitations of the human mind. Our
							brains can only deal with a small number of concepts at a time.</p>
						<a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/">Category Theory for Programmers, Bartosz Milewski</a>
					</blockquote>
					<p>I couldn't agree more with above statements. We do decompose and compose objects using object oriented languages or procedures when procedural
						languages come to play. Ability to compose is the very nature of pure functions, they just accept value ant return value, so we can take any number of
						functions and chain them in the way, that the result of previous function becomes an input of next function. Just like in following example:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition.java" data-format="skip-class"></code></pre>
					<p>
						I agree, it's not very useful. Lets look at more realistic example. We have simple task: write function accepting user provided string and convert it to
						percent format if possible. In case of non-number input, just return <em>0 %</em>.
					</p>
					<p>This is our first attempt:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition1.java" data-format="skip-class"></code></pre>
					<p>
						It looks fine at first glance, but there are some issues in it. It does more than one thing: parses <code>String</code> to <code>BigDecimal</code>,
						multiplies result by 100, appends ' %' suffix, handle errors. All those actions are hidden inside function body and can't be reused or tested separately.
					</p>
					<p>Let's decompose it into smaller chunks and compose back to create our final function.</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition2.java"></code></pre>
					<p>
						Well, we have small functions but composing them is the real pain, isn't it? What can we do about this? We can use Java 8 <code>java.util.function.Function</code>
						and partial application to make them easier to use.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition3.java"></code></pre>
					<p>I particularly like the expressiveness of our functions application in last lines. It's like some story told:</p>
					<ul>
						<li>
							apply <code>parse</code> safely
						</li>
						<li>then multiply by 100</li>
						<li>then append ' %' string</li>
						<li>call with '0.5' argument</li>
					</ul>
					<p>
						Let me explain the magic happening in last lines. We use <code>andThen</code> default method of <code>java.util.function.Function</code> interface. This
						is commented piece of this interface source code:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/corecompose/Function.java"></code></pre>
					<p>
						Whenever we need to apply multiple functions (let's say three functions named <em>f</em>, <em>g</em>, <em>h</em>) one after another like in this
						pseudocode <code>f(g(h(X x)))</code> , where <code>x</code> is argument of type <code>X</code>, we can use <code>andThen</code> higher order function like
						here: <code>h.andThen(g).andThen(f).apply(x)</code>.
					</p>
					<p class="note">
						<code>h</code> function's result becomes <code>g</code> function's argument, and <code>g</code> function's result becomes <code>f</code> function's
						argument.
					</p>
					<p>
						We can apply multiple functions in opposite direction using <code>compose</code> like this: <code>h(g(f(X x)))</code>. Corresponding code would be: <code>h.compose(g).compose(f).apply(x)</code>.
					</p>
					<p class="note">
						<code>f</code> function's result becomes <code>g</code> function's argument, and <code>g</code> function's result becomes <code>h</code> function's
						argument.
					</p>
					<p>
						These are our task's functions combined using <code>compose</code>:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition4.java"></code></pre>
					<p>Let's get back to our task. Although the way we call our functions looks better (of course only if we get used to this notation), we had to write
						much more code compared to first version. Fortunately, there is the light ...</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Composition5.java"></code></pre>
					<p>
						We didn't have to create our composing functions at the expense of readability. You might ask which way to go then? I would argue that having small
						generic functions that can be reused to compose other functions is the good approach. There are plenty of reusable functions available in Java Core API or
						external libraries, they are thoroughly tested and can save a lot of our time. Such generic functions are called <em>combinators</em> and libraries
						containing them <em>combinator libraries</em>.
					</p>
					<p>
						Let's practice little bit and solve some simple tasks using only our combinators like <code>partial</code> or <code>applySafe</code>, functions from <em>Java
							Core API</em> and from <em>Apache Commons Lang</em> library.
					</p>
					<p class="exc">
						Extend our percent parsing function to trim input string before application.
						<a class="ans" data-toggle="collapse" href="#percentParserTrim">Show answer</a>
					</p>
					<pre class="collapse" id="percentParserTrim"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/PercentParserTrim.java"></code></pre>
					<p class="exc">
						Extend our trimming percent parsing function to add two fraction digits.
						<a class="ans" data-toggle="collapse" href="#percentParserScale">Show answer</a>
					</p>
					<pre class="collapse" id="percentParserScale"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/PercentParserScale.java"></code></pre>
					<p>Although we have limited number of our programming tools, just higher order functions, partial application and composition, the amount of possible
						combinations of ways we can structure our code is huge. The only limitation is our imagination ... and Java compiler of course.</p>
					<h3>Identity</h3>
					<p>
						Can you imagine math without concept of zero? I believe you can't. Zero is the specialization of neutral element. When neutral element is used in some
						operation, final result is not affected. Like zero under number addition <code>x + 0 = x</code> or one under multiplication <code>x * 1 = x</code>. The
						exact type and value of neutral element depends on the context. It can be number in arithmetic operations or function in functions composition. It may
						seem useless and unnecessary, but there are multiple possible usages of identity element I will write about in next post. This is identity function in
						Java 8:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/coreidentity/Function.java"></code></pre>
					<p>Identity function does nothing more than returning it's argument. When used in functions composition it leaves composed function unchanged:</p>
					<p class="note">
						<code>f.andThen(Function.identity()) == f</code> and <code>f.compose(Function.identity()) == f</code>
					</p>
					<p>
						And here comes code example with <code>Function.identity()</code>:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/Identity.java"></code></pre>
					<p>
						Let's try to optimize our trimming parser naively just to present <code>Function.identity()</code> use. We want to extend our parser to do some cleanup
						before actual parsing.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/PercentParserClean.java"></code></pre>
					<p>
						This trivial example shows the way we can use <code>Function.identity()</code> to do nothing under some circumstances. And here below is simple trick we
						can use to compose functions when our starting function is just static method, so no <code>andThen()</code> or <code>compose()</code> methods are
						available.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/IdentityCompose.java"></code></pre>
					<h3>Side effects separation and explicit state mutation</h3>
					<p>
						Pure functions here, pure functions there, pure functions everywhere. What about writing to file or socket or reading user's input from console? All such
						<em>side effects</em> are forbidden for pure functions. The way to handle side effects in functional programming is to separate pure code from side
						effects code. Let's say we write program fragment responsible for casino players verification. We want to print warning if player's name is on dangerous
						players list or usual message otherwise.
					</p>
					<p>This is impure version:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/SideEffectsImpure.java"></code></pre>
					<p>It's very tempting but I will not complain about the number of issues in this code. It's time for pure version where we will try to separate pure
						from side effects code.</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/SideEffectsPure.java"></code></pre>
					<p>
						The solution is to not perform side effect but to return side effect performing function from pure code. <code>java.util.function.Consumer</code> is the
						special function. It accepts single generic argument but returns <code>void</code>. If it returns meaningless value, it's sole purpose is to perform side
						effects.
					</p>
					<p>
						Our goal was to separate side effects from pure code but we failed. Our <code>verifyPlayer</code> function is still impure, because it returns constants
						not included in arguments. Let's refactor it.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/SideEffectsPure2.java"></code></pre>
					<p>
						Our <code>verifyPlayer</code> function is pure now but still not perfect. It's arguments list is long and it performs only very specific logic. What if we
						would like to choose side effect basing on some other condition? We would have to write another function. Not very reusable right? Let's look at the code
						again and try to abstract it more generic form. The very first thing coming into my mind is the <code>if()</code> condition in line 9. It's just <code>Predicate</code>.
						We can refactor our function to use predicate.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/SideEffectsPure3.java"></code></pre>
					<p>
						Finally, let's go crazy and make our player handler selection the higher order function for easier use, generic as there is nothing specific to our <code>Player</code>
						in functions's implementation and let's compose additional handler of dangerous players.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p1/SideEffectsPure4.java"></code></pre>
					<p>
						We used known techniques to achieve desired result: higher order functions, currying and composition. The only new thing is <code>Consumer&lt;A&gt;</code>
						composition using <code>andThen()</code> default method.
					</p>
					<p>
						I will leave the answer for question: <em>Why there is no <code>compose()</code> function in <code>java.util.function.Consumer</code> interface?
						</em> to you dear readers as an exercise.
					</p>
					<h2>What's next?</h2>
					<p>In next post you will read why it's worth to learn functional programming.</p>
				</div>
			</div>
		</div>
	</article>
	<hr>
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-lg-8 col-md-10 mx-auto">
					<ul class="list-inline text-center">
						<li class="list-inline-item">
							<a href="https://www.linkedin.com/in/daniel-las" target="_blank">
								<span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
								</span>
							</a>
						</li>
					</ul>
					<p class="copyright text-muted">
						Copyright &copy; Daniel Łaś 2019, Look and feel forked from
						<a href="https://startbootstrap.com/template-overviews/clean-blog/" target="blank">Clean Blog</a>
					</p>
				</div>
			</div>
		</div>
	</footer>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
	<div class="alert text-center cookiealert">
		We use cookies to ensure you get the best experience on our site.
		<button class="btn btn-primary btn-sm acceptcookies">I agree</button>
	</div>
	<script src="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.js"></script>
	<script src="../js/clean-blog.min.js"></script>
	<script src="../js/examples.min.js"></script>
</body>
</html>
