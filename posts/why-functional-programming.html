<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Functional Programming, Java">
<meta name="author" content="Daniel Łaś">
<title>Daniel Łaś Tech Blog</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
<link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet'
	type='text/css'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.css">
<link href="../css/clean-blog.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js" data-manual></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12045869-7"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'UA-12045869-7');
</script>
</head>
<body>
	<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
		<div class="container">
			<a class="navbar-brand" href="../index.html">Home</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive"
				aria-expanded="false" aria-label="Toggle navigation">
				Menu <i class="fas fa-bars"></i>
			</button>
			<div class="collapse navbar-collapse" id="navbarResponsive">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link" href="../index.html">Home</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../about.html">About</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../contact.html">Contact</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>
	<header class="masthead sm">
		<div class="overlay"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<div class="post-heading text-center">
						<h1>Why functional programming?</h1>
						<h2 class="subheading">It does make the difference ...</h2>
					</div>
				</div>
			</div>
		</div>
	</header>
	<article>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<p>
						This is second part of pragmatic functional programming tutorial for Java developers. If you read my previous post regarding
						<a href="functional-programming-magic.html">what functional programming is</a>
						, well ... <em>I'm glad you are back :)</em> If you didn't, <em>please take a look there</em> as I'm going to write about concepts described previously.
					</p>
					<p>We know basic concepts and techniques of functional programming. It's time for some advertising, why it's good to use these techniques and concepts
						and how they will improve our code.</p>
					<h2>Concurrent and parallel computations</h2>
					<p>
						If we look at microprocessors parameters historical data, like here:
						<a href="https://www.karlrupp.net/2018/02/42-years-of-microprocessor-trend-data/">42 Years of Microprocessor Trend Data </a>
						, we can draw interesting conclusions.
						<a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore's law</a>
						still holds as number of transistors grows exponentially. Single thread performance increases slightly. The number of cores increases with a power law.
					</p>
					<p>Once we have multiple cores available, it's not the big deal to make our programs concurrent. Just spawn tasks in separate threads and we are done.
						The real difficulty is in making our programs parallel.</p>
					<p class="note">
						There is essential difference between <em>concurrent</em> and <em>parallel</em> programs. <em>Concurrent</em> programs are capable to do different things
						at the same time, like accepting keyboard input and writing to disk simultaneously. <em>Parallel</em> programs are able to split single task into smaller
						parts and execute them in the same time on different processor cores or cluster nodes to complete faster, like sorting or computing some value from large
						data set.
					</p>
					<p>There is difficult task of performing parallel computations at the front of us, to benefit from increasing microprocessors computation power and
						different approaches to parallelism exist.</p>
					<h3>Java concurrency model</h3>
					<p>
						The traditional approach in Java is to use shared state and protect it against concurrent access. Simply stating: <span class="badge badge-secondary">1</span>
						we run tasks simultaneously in separate threads, <span class="badge badge-secondary">2</span> every task updates shared state on completion, <span
							class="badge badge-secondary">3</span> we assure that only one task can update shared state at the same time. We can protect shared state using Java
						language built in features like <code>synchronized</code> methods and blocks, locking primitives from <code>java.util.concurrent.locks</code> core
						package. Looks easy and it is indeed ... for simple cases, but believe me, it's rapidly becoming extremely complex for more sophisticated cases. We can
						make our programs thread safe by synchronizing all shared states, but it makes them serial and our parallelism goes down the drain. We can make our
						programs more parallel by careful design, but we expose ourselves to multiple dangers like:
					</p>
					<ul>
						<li>race conditions</li>
						<li>threads starvation, deadlock and similar effects</li>
						<li>testing difficulties</li>
						<li>context switching overhead</li>
					</ul>
					<p>Above issues produce many bugs, usually occurring in production environments and almost impossible to reproduce and test.</p>
					<p class="note">
						According to Murphy's law, <em>If something can go wrong, it will go wrong ... when we are on vacations ... and our sales guys are performing VERY
							IMPORTANT presentation for VERY IMPORTANT prospect client</em>.
					</p>
					<p>Traditional model is difficult, lets consider some other options.</p>
					<h3>Parallelism in functional programming</h3>
					<p>
						In functional programming we use <em>pure functions</em> to construct our programs. It implies no side effects nor shared state, so there is no need for
						synchronization. We can safely run parallel computation because there is no need for shared state synchronization.
					</p>
					<p>
						Before we start to parallelize our computation, we have to answer very important question - <em>Can it be parallelized at all?</em>
					</p>
					<p>
						The answer depends on it's ability to be divided into pieces that can be executed in parallel. The bigger part of program can be parallelized then better.
						However, there are some theoretical limits described by
						<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's law</a>
						. Deciding if our program is a good candidate for parallelization is sometimes difficult. Usually we have some source of data and run computation on every
						element from this source. More divisible is the source and more costly is the single element processing, chances are higher that we can benefit from
						running it in parallel manner. However we split our job, either recursively or by some collection division, we need to take care of available parallelism
						level determined by number of cores or nodes.
					</p>
					<p>Let's make our hands dirty and write parallel program. The simplest case of parallel computation is:</p>
					<p class="note">we have data set, we want to perform some long running calculation on every element from set and finally receive transformed data set
						of the same length as input data set.</p>
					<p>Like for example fractals generation.</p>
					<p class="text-center">
						<img src="../img/mandelbrot.png" />
					</p>
					<p>
						Above image is the fractal generated using
						<a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot's</a>
						formula. To generate fractal we perform some iterative algorithm for every point in the image and set it's color depending on algorithm result.
					</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p2/MandelbrotTest.java"></code></pre>
					<p>
						If you want to look at <code>Point</code> class and <code>mandelbrot</code> function,
						<a class="ans" data-toggle="collapse" href="#mandelbrot">click here</a>
						.
					</p>
					<pre class="collapse" id="mandelbrot"><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/Mandelbrot.java"></code></pre>
					<ul>
						<li>
							Interesting code starts at line <span class="badge badge-secondary">7</span> where we create list of <code>Point</code> type objects representing image
							of given width and height. If you don't entirely understand what's going on there, don't worry, it's just Java Streams way to create nested loops.
						</li>
						<li>
							The main part starts at line <span class="badge badge-secondary">14</span>, where we create <code>Stream</code> from the points list and process it in
							parallel (thanks to <code>parallel</code> stream operator used in line <span class="badge badge-secondary">15</span>) applying pure <code>mandelbrot</code>
							function (in line <span class="badge badge-secondary">16</span>) to every point from list. <code>mandelbrot</code> function is pure regardless of it's
							internal imperative implementation, because all side effects are enclosed within function scope. All the labor of splitting the list, submitting tasks to
							thread pool and gathering results is done by great Java Stream framework.
						</li>
						<li>
							Since we don't care about ordering we perform side effect using <code>forEach</code> operator at line <span class="badge badge-secondary">17</span>. We
							don't have to care about image object synchronization because <code>BufferedImage</code> just an array and we write color value to different array cells.
						</li>
					</ul>
					<p class="note">
						We are safe to do parallel computation writing just several lines of code thanks to very simple and extremely important fact: our mapping function is <em>pure</em>.
					</p>
					<p>
						It was easy, but what about another use case: we have large data set and want to calculate single result from it, like sum or mean? Can we do this in
						parallel? Here comes the to the rescue very abstract beast named <em>Monoid</em>. I'll provide short description here and will write separate post about
						Monoid as this concept truly deserves it.
					</p>
					<h3>Monoids</h3>
					<p class="note">Monoid is a type, associative binary operation and neutral element called identity.</p>
					<p>
						Integer addition together with 0 forms Monoid. The type is <code>java.lang.Integer</code>. The binary operation is addition: <code>a + b = c</code>. We
						name it binary because it operates on two arguments - it's just <code>java.util.function.BiFunction&lt;T,T,T&gt;</code> or specialized <code>java.util.function.BinaryOperator&lt;T&gt;</code>.
						It's associative because it's insensitive to parentheses when composed with higher number of arguments: <code>a + (b + c) == (a + b) + c</code>.
						Addition's identity element is 0, because: <code>a + 0 == a</code>. There are three laws Monoid must obey. I'll write about them in details in dedicated
						post, here is just the list: <em>Left identity</em>, <em>Right identity</em> and <em>Associativity</em> law. The most important fact in the context of
						parallel computations is:
					</p>
					<p class="note">If our computation forms Monoid, it's safe to run it in parallel.</p>
					<p>Here below is integer addition Monoid in action.</p>
					<pre class="line-numbers"><code class="language-java" data-src="../src/test/java/tech/daniellas/p2/AdditionMonoidTest.java"></code></pre>
					<ul>
						<li>
							In line <span class="badge badge-secondary">4</span> we start our data set construction.
						</li>
						<li>
							In line <span class="badge badge-secondary">9</span> we make our stream parallel.
						</li>
						<li>
							Finally we use Monoid in <code>reduce</code> stream operator in line <span class="badge badge-secondary">9</span>, providing identity element equal 0 and
							<code>Integer::sum</code> as binary associative operation.
						</li>
					</ul>
					<p>
						As you can see, Java 8 introduced concept of Monoid. If you don't believe me, take a look at <code>reduce</code> operator JavaDoc documentation. Do I need
						to emphasize that our binary operation must be pure function?
					</p>
					<h3>What about functional concurrency?</h3>
					<p>
						There is something very useful in regards of concurrency, ubiquitous and very simple. This is <em>Monad</em>. I know two "functional" jokes, this is first
						one:
					</p>
					<blockquote>
						<p>A monad is just a monoid in the category of endofunctors.</p>
					</blockquote>
					<p>If you think it's not funny, you can always blame my sense of humor.</p>
					<p>I will write more about Monads in next posts as Mondas also deserve it, but here I'll just shed some light on Monads.</p>
					<p>
						Monads are ubiquitous, they are present in Java starting from version 8: <code>Optional</code>, <code>Stream</code> and <code>CompletableFuture</code> are
						all Monads. One of Monad's powers lies in the fact that we use them always in the same way. Once we grasp the concept, many problems solutions become
						obvious.
					</p>
					<p>
						For example, we use <code>Optional.of()</code> or <code>Optional.empty()</code> to create either <code>Optional</code> with some value in it or empty.
						Then we use <code>Optional.flatMap()</code> to transform it's value using function also returning <code>Optional</code>.
					</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/p2/monads/OptionalTest.java"></code></pre>
					<p>
						We use <code>CompletableFuture</code> to compose computations where result may be available in the future or not at all. <code>CompletableFuture.supplyAsync()</code>
						acts as <code>Optional.of()</code> and <code>CompletableFuture.thenCompose()</code> plays the same role as <code>Optional.flatMap()</code>.
					</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/p2/monads/CompletableFutureTest.java"></code></pre>
					<p>
						Let's compare <code>Optional.flatMap()</code> and <code>CompletableFuture.thenCompose()</code> signatures (without <em>public</em> modifiers):
					</p>
					<pre><code class="language-java" data-format="lines 7,7" data-src="../src/main/java/tech/daniellas/p2/OptionalSign.java"></code></pre> <pre><code
						class="language-java" data-format="lines 8,9" data-src="../src/main/java/tech/daniellas/p2/CompletableFutureSign.java"></code></pre>
					<p>If we'll look closely at both signatures, similarity will become obvious. Both methods return Monad and take as an argument function accepting
						contained value and returning Monad as well. Existence of such method is one of Monads core features.</p>
					<p>
						The point here is that we really use Monads the same way - we safely compose multiple computations. In our examples, <code>Optional</code> is the guard
						against null values, where <code>ComplatableFuture</code> protects us from performing computations on data that has never arrived due to some error, by
						executing consecutive computations only when data becomes available.
					</p>
					<p>
						It's time for real icing on the cake in regards of concurrent computations done monadic way with <code>CompletableFuture</code>. We all know how difficult
						to test asynchronous code even when underlying services are mocked. Hopefully, many <code>CompletableFuture</code> methods are overloaded and accept
						additional argument of type: <code>java.util.concurrent.Executor</code>. <code>Executor</code> is simple functional interface:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/Executor.java"></code></pre>
					<p>
						We can use overloaded <code>CompletableFuture</code> methods and provide custom <code>Executor</code> implementation executing supplied code in current
						thread for testing purpose:
					</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/p2/monads/CompletableFutureWithSameThreadExecutorTest.java"></code></pre>
					<p class="note">The very nature of Monads gives us guarantee that our concurrent computations will execute the same way on production as when executed
						in tests.</p>
					<h2>Functional SOLIDity</h2>
					<p>
						Functional programming helps us to comply with <em>SOLID</em> principles in some way. <em>SOLID</em> principles are more related to Object Oriented
						paradigm, but still relevant and valuable in functional programming realm. I don't mean that it's impossible to write bad and ugly programs using
						functional paradigm. I just mean that functional programming encourages us to do things the right way.
					</p>
					<p>
						Let's look at
						<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility principle</a>
						first. Pure functions accept values and always return same value if applied to same arguments. The only purpose of function is to perform calculation
						without side effects. If our function's argument number is within reason and we don't pass the whole environment as argument, we are constrained to
						implement just <em>single feature</em>.
					</p>
					<p>
						<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open-Closed principle</a>
						is followed naturally when we use higher order functions. Once simple function is implemented and is correct, there is no need to change it. If we want it
						to be extendible, we just use other function as it's argument.
					</p>
					<p>
						<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a>
						doesn't fit directly into functional programming as it's coupled to class inheritance concept. According to this principle, we should be able to replace
						objects with subclass implementations without breaking the program. It states in less formal language: <i>If we have class A and extend it with class
							B, class B overrides some method of class A, this method should accept at least the same subset of input parameter values and should return values within
							subset of values returned by class B from this method.</i> We are not allowed to restrict possible input values and extend possible return values. If this
						principle is not used, safe replacement of objects with instances of subclass might cause errors. Liskov principle is a good practice in functional
						programming too. Using higher order functions we expect that any functions passed as an argument will accept any allowed argument and will return value
						within allowed set.
					</p>
					<p>
						<a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation principle</a>
						fits perfectly. Just take a look at any interface annotated with <code>@FunctionalInterface</code>. Using this annotation we enforce compile time check
						whether out interface defines single abstract method. When programming with higher order functions we depend only on single function and function is the
						most succint interface with only one method (apart from interfaces with no methods implying very limited usability).
					</p>
					<p>
						<a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion principle</a>
						lies at the bottom of functional programmers heart. We enforce it on lowest possible level, not only when designing modules. If we use only functions, we
						restrict possible abstractions so there is no way to create coupling by unfortunate design.
					</p>
					<h2>Loose coupling</h2>
					<p>Functional code is loosely coupled by its nature. When you give it a try by gradually introducing functions, you'll notice how greatly it reduces
						coupling. This is because we can think about the class in terms of set of functions. If we need only one method from some external class, we can use only
						this method without knowledge about this particular class interface. Here below is the example of this technique.</p>
					<p>
						Let's say that we have simple class responsible for storing mapping of some people and their ID numbers. The mapping can be implemented as simple
						key/value store. We can add new mapping and find ID number by user id. We also do some validation before we add new mapping. We implemented the store as
						simple <code>HashMap</code> and keep in memory.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/coupled/IdNumberHolder.java"></code></pre>
					<p>
						Not very sophisticated code but it does some job. Later on, we decided to use JDBC <code>DataSource</code> instead of in memory implementation. With
						current design, we are coupled to <code>HashMap</code> and we have to rewrite our code. But we can do way better:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/decoupled/IdNumberHolder.java"></code></pre>
					<p>
						This simple technique removed dependency on both <code>HashMap</code> and <code>JdbcTemplate</code> types from our implementation. We easily created
						loosely coupled code conforming to Open Closed, Interface Segregation and Dependency Inversion principles.
					</p>
					<h2>Testability</h2>
					<p>
						Testing functional code is extremely easy. We just have to call tested function and assert the result. Usually, we even don't need to use mocks. Let's
						rewrite our <code>IdNumberHolder</code> to functions first and then test them.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/fun/IdNumbers.java"></code></pre>
					<p>This is the test suite for our functions:</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/p2/fun/IdNumbersTest.java"></code></pre>
					<p>
						That's it. Without comments our test code would be of similar size as tested code. This is enough to achieve 100% test coverage. We don't have to use any
						mocking framework. I've left <code>BiConsumer</code> as persister implementation deliberately, to point out how tricky things can be if we don't use pure
						functions. It's very tempting to pass validation rules as <code>Predicate</code> to <code>IdNumbers.save()</code> function, but I'll leave it to you dear
						readers.
					</p>
					<h2>Tell me what's your code doing</h2>
					<p>
						Out of functions purity follows <em>Referential transparency</em> feature. Referential transparency means that any referentially transparent function or
						expression, can be replaced with value it produces without changing the result of the program. Of course we can't replace functions with some arbitrary
						numbers and expect it to work the same way. What we can do is to replace function with value it produces for given input:
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/rt/ReferentialTransparcency.java"></code></pre>
					<p>
						<em>This code is weird, doesn't it? We are testing the obvious. It's enough to look at the code and explain it.</em>
					</p>
					<p>
						That's what we as programmers are doing all the time. We are reasoning about our or other's code in code reviews, during pair programming sessions or
						discussions. Referentially transparent code is much easier to reason about than imperative code with side effects. What's better, referentially
						transparent program can be proved using <em>Equational reasoning</em>. If you have ever been solving equations in school you are already familiar with
						this technique idea. During equational reasoning, we analyse the program or function result for given input by gradually replacing every expression and
						function with result thus reducing the code to very simple equality expression. Let's try to prove some code using equational reasoning.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/rt/AddTwoProof.java"></code></pre>
					<p>Above assertions chain can be written on piece of paper:</p>
					<pre><code data-src="../src/main/java/tech/daniellas/p2/rt/AddTwoProof.txt"></code></pre>
					<p class="note">We can safely use equational reasoning only if referential transparency holds.</p>
					<p>
						Let's try to prove some more complicated function from previous post - <code>percentParser</code>:
					</p>
					<p class="exc">
						Write function accepting user provided string and convert it to percent format if possible. In case of non-number input, just return <em>0 %</em>.
					</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/p2/rt/PercentParserProof.java"></code></pre>
					<p>And the same in form of equations:</p>
					<pre><code data-src="../src/main/java/tech/daniellas/p2/rt/PercentParserProof.txt"></code></pre>
					<p>
						This time we had to evaluate two equations because there are two possible outputs for <code>createBigDecimal()</code> function: either parsed number or 0
						in case of non number string provided as the argument. Our common sense let us reason that this should be enough.
					</p>
					<p>Usually we don't do this in form of tests or written equations but we do it in our minds all the time. In case of side effects embedded in our
						functions, the number of possible branches to analyse or test would grow and reasoning about the code would become much more difficult.</p>
					<h2>What's next?</h2>
					<p>
						In next post you will read about .
					</p>
				</div>
			</div>
		</div>
	</article>
	<hr>
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-lg-8 col-md-10 mx-auto">
					<ul class="list-inline text-center">
						<li class="list-inline-item">
							<a href="https://www.linkedin.com/in/daniel-las" target="_blank">
								<span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
								</span>
							</a>
						</li>
					</ul>
					<p class="copyright text-muted">
						Copyright &copy; Daniel Łaś 2019, Look and feel forked from
						<a href="https://startbootstrap.com/template-overviews/clean-blog/" target="blank">Clean Blog</a>
					</p>
				</div>
			</div>
		</div>
	</footer>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
	<div class="alert text-center cookiealert">
		We use cookies to ensure you get the best experience on our site.
		<button class="btn btn-primary btn-sm acceptcookies">I agree</button>
	</div>
	<script src="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.js"></script>
	<script src="../js/clean-blog.min.js"></script>
	<script src="../js/examples.min.js"></script>
</body>
</html>
