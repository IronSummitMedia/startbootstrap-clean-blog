<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Functional Programming, Java, Java 8 streams benchmarks ">
<meta name="author" content="Daniel Łaś">
<title>Daniel Łaś Tech Blog - Speed of stream. Nice but slow abstraction? Myths debunked.</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
<link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet'
	type='text/css'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.css" />
<link rel="stylesheet" type="text/css" href="http://cdn.jsdelivr.net/npm/taucharts@2/dist/taucharts.min.css" />
<link href="../css/clean-blog.min.css" rel="stylesheet">
<style type="text/css">
.chart {
	height: 250px;
}

#streams-group-chart {
	height: 400px;
}

table.benchmark tr.selection {
	cursor: pointer;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js" data-manual></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.2/d3.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/taucharts@2/dist/taucharts.min.js" type="text/javascript"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12045869-7"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'UA-12045869-7');
</script>
</head>
<body>
	<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
		<div class="container">
			<a class="navbar-brand" href="../index.html">Home</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive"
				aria-expanded="false" aria-label="Toggle navigation">
				Menu <i class="fas fa-bars"></i>
			</button>
			<div class="collapse navbar-collapse" id="navbarResponsive">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link" href="../index.html">Home</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../about.html">About</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../contact.html">Contact</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>
	<header class="masthead sm">
		<div class="overlay"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<div class="post-heading text-center">
						<h1>Speed of stream</h1>
						<h2 class="subheading">Are streams nice but slow abstraction? Myths debunked.</h2>
					</div>
				</div>
			</div>
		</div>
	</header>
	<article>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<p>From time to time I witness or am involved it the discussion about Java 8 Streams performance. The common knowledge is that streams are the
						compromise between performance and terse although very descriptive abstraction. I couldn't find any comprehensive set of benchmarks around so decided to
						write by myself. Here below I present gathered results.</p>
					<h2>What and how was tested</h2>
					<p>
						I measured performance of several different use cases of <code>forEach</code> application, like applying some function to list of numbers and summing it
						or filtering and grouping such list - usual programming tasks. The same tasks were implemented with different flavours of <code>Stream</code>.
					</p>
					<p>
						The choice regarding benchmarking tools seemed easy, battle tested microbenchmark toolkit - <a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH</a>
						maintained under umbrella of OpenJDK. It's very flexible and easy to use.
					</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#jmh">See benchmark runner configuration</a>
					</p>
					<pre class="collapse" id="jmh"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/BenchmarkBase.java"
						data-format="lines 17,42"></code></pre>
					<p>
						Most of the benchmarks were run on some elements list of different sizes: <em>1000</em>, <em>10 000</em>,<em>100 000</em>, <em>1 000 000</em> to verify
						how given implementation performs depending on number of elements it has to process.
					</p>
					<p>
						The JVM arguments passed in every test were: <em>-Xms2G -Xmx2G -XX:+UseG1GC</em>. The JVM version used was: <em>Java HotSpot(TM) 64-Bit Server
							1.8.0_201</em>.
					</p>
					<p>
						Benchmark results are presented on charts in <em>percents of best result</em> to easily compare results between different sample sizes. Best result is <em>100
							%</em>. When you see <em>50 %</em> score on the chart, it means that this benchmark was half good as the best one
					</p>
					<p>
						Results are also displayed in tables in <em>number of operations per second</em> unit. Best results are emphasized.
					</p>
					<h2>Sum of integers</h2>
					<p>This is first benchmark comparing performance of summing integer numbers from list.</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#intsum">See benchmark code</a>
					</p>
					<pre class="collapse" id="intsum"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/IntegerSumBenchmark.java"></code></pre>
					<div class="chart" id="streams-sum-int-chart"></div>
					<p class="legend">You can limit series visible on charts by selecting them from the legend at the top right corner.</p>
					<p>And this is results table.</p>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-sum-int-table">
						</tbody>
					</table>
					<p class="legend">You can select rows to make it more readable.</p>
					<p>
						It was easy to predict. We have clear winner: <code>forEach</code>, but it's advantage was decreasing with larger items numbers, especially when compared
						to parallel version of <code>collect</code>. Sequential <code>collect</code> is better on <em>1000</em> elements, but then parallel version starts to move
						ahead. <code>reduce</code> don't perform well at all, worst in almost all cases but again, parallel stream with <code>reduce</code> is doing better when
						sample is bigger.
					</p>
					<p class="note">
						If greatest part of your program is responsible for summing reasonable big number of integers, go for <code>forEach</code>.
					</p>
					<p>
						If you think I'm little bit sarcastic here ... you are right. It's very unlikely that this level of performance optimizations matters, especially in the
						world of <em>REST APIs</em>, <em>Microservices</em> and <em>Event Driven</em> architectures. If we replace <code>Stream.collect()</code> with <code>forEach</code>
						to sum <em>100 000</em> integers obtained via some REST endpoint, we don't profit much. We gain tenths of microseconds compared to seconds required to
						fetch data from database, serialize, transfer over the wire and deserialize.
					</p>
					<h2>Sum of calculations</h2>
					<p>Let's take more realistic task this time: perform some math operation on list of randomly generated floating-point numbers and sum all calculated
						values.</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#doublesum">See benchmark code</a>
					</p>
					<pre class="collapse" id="doublesum"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/DoubleCalculationBenchmark.java"></code></pre>
					<div class="chart" id="streams-sum-double-calculation-chart"></div>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-sum-double-calculation-table">
						</tbody>
					</table>
					<p>
						Well, what a surprise! <code>forEach</code> score is more or less the same as of sequential stream based versions. Parallel stream implementations are
						about 3 - 5 times faster. Actually, such results are quite easy to explain.
					</p>
					<p class="note">
						There are cost related to <code>Stream</code> creation and threads coordination that can't be mitigated when number of operations to parallelise is small
						or the operation itself is fast.
					</p>
					<p>
						We didn't observe such quick benefits of parallel streams in previous benchmark. According to <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's
							law</a> defining theoretical limits of parallelism - the greater part of our program is run sequentially, less parallel it can be. This is exactly the case
						for summing list of integers. Two integers addition is very fast operation, so inherently sequential part responsible for threads synchronization
						prevailed, especially in case of relatively small quantity of items in the list.
					</p>
					<p>
						The same law caused slightly better performance of <code>reduce</code> operation in this benchmark. <code>reduce</code> contract requires to use binary
						associative operation, free from side effects and working on immutable objects. <code>Double.sum()</code> falls into this category. If we obey these
						constraints, no synchronization is required during partial results merge.
					</p>
					<h2>Grouping</h2>
					<p>
						Grouping some data set is easy, concise and very descriptive with streams therefore is really frequently used, at least in the code I see on a daily
						basis. This feature was compared with version implemented imperatively using <code>forEach</code> loop in this benchmark. There are plenty of variations
						that might affect performance: stream can be sequential or parallel, ordered o unordered, we have several options choosing collector. We can use <code>Stream.reduce()</code>
						operator instead of <code>Stream.collect()</code> or different data structures as grouping containers.
					</p>
					<p>
						The benchmarked task is: take list of randomly generated <code>Double</code>'s group by result of division by 100. Produced result is of type <code
							class="text-nowrap">Map&lt;Double, List&lt;Double&gt;&gt;</code>.
					</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#filtergroup">See benchmark code</a>
					</p>
					<pre class="collapse" id="filtergroup"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/GroupBenchmark.java"></code></pre>
					<div class="chart" id="streams-group-chart"></div>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-group-table">
						</tbody>
					</table>
					<h2>Words frequency</h2>
					<h3>Original code</h3>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table">
								</tbody>
							</table>
						</div>
					</div>
					<h3>Step 1 - Using tokenizer stream</h3>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart1"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table1">
								</tbody>
							</table>
						</div>
					</div>
					<h3>Step 2 - Parallel</h3>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart2"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table2">
								</tbody>
							</table>
						</div>
					</div>
					<h3>Step 3 - Single pass</h3>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart3"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table3">
								</tbody>
							</table>
						</div>
					</div>
					<h3>Step 4 - Single pass parallel</h3>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart4"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table4">
								</tbody>
							</table>
						</div>
					</div>
				</div>
			</div>
		</div>
	</article>
	<hr>
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-lg-8 col-md-10 mx-auto">
					<ul class="list-inline text-center">
						<li class="list-inline-item">
							<a href="https://www.linkedin.com/in/daniel-las" target="_blank"> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i
									class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
							</span>
							</a>
						</li>
					</ul>
					<p class="copyright text-muted">
						Copyright &copy; Daniel Łaś 2019, Look and feel forked from <a href="https://startbootstrap.com/template-overviews/clean-blog/" target="blank">Clean
							Blog</a>
					</p>
				</div>
			</div>
		</div>
	</footer>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
	<div class="alert text-center cookiealert">
		We use cookies to ensure you get the best experience on our site.
		<button class="btn btn-primary btn-sm acceptcookies">I agree</button>
	</div>
	<script src="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.js"></script>
	<script src="../js/clean-blog.min.js"></script>
	<script src="../js/examples.1.0.0.min.js"></script>
	<script src="../js/charts.1.0.0.min.js"></script>
</body>
</html>
