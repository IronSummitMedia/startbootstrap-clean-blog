<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Functional Programming, Java, Java 8 streams benchmarks ">
<meta name="author" content="Daniel Łaś">
<title>Daniel Łaś Tech Blog - Speed of stream. Nice but slow abstraction? Myths debunked.</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">
<link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
<link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet'
	type='text/css'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.css" />
<link rel="stylesheet" type="text/css" href="http://cdn.jsdelivr.net/npm/taucharts@2/dist/taucharts.min.css" />
<link href="../css/clean-blog.min.css" rel="stylesheet">
<style type="text/css">
.chart {
	height: 250px;
}

.chart-lg {
	height: 400px;
}

table.benchmark tr.selection {
	cursor: pointer;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js" data-manual></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.4/fetch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.2/d3.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/taucharts@2/dist/taucharts.min.js" type="text/javascript"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12045869-7"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'UA-12045869-7');
</script>
</head>
<body>
	<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
		<div class="container">
			<a class="navbar-brand" href="../index.html">Home</a>
			<button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive"
				aria-expanded="false" aria-label="Toggle navigation">
				Menu <i class="fas fa-bars"></i>
			</button>
			<div class="collapse navbar-collapse" id="navbarResponsive">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link" href="../index.html">Home</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../about.html">About</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../contact.html">Contact</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>
	<header class="masthead sm">
		<div class="overlay"></div>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<div class="post-heading text-center">
						<h1>Speed of stream</h1>
						<h2 class="subheading">Is Java 8 Stream nice but slow abstraction? Myths debunked.</h2>
					</div>
				</div>
			</div>
		</div>
	</header>
	<article>
		<div class="container">
			<div class="row">
				<div class="col-md-10 mx-auto">
					<p>From time to time I witness or am involved it the discussion about Java 8 Streams performance. The common knowledge is that streams are the
						compromise between performance and terse although very descriptive abstraction. I couldn't find any comprehensive set of benchmarks around so decided to
						write by myself. Here below I present gathered results.</p>
					<h2>What and how was tested</h2>
					<p>
						I measured performance of several different use cases of <code>forEach</code> application, like applying some function to list of numbers and summing it
						or filtering and grouping such list - usual programming tasks. The same tasks were implemented with different flavours of <code>Stream</code>.
					</p>
					<p>
						The choice regarding benchmarking tools seemed easy, battle tested microbenchmark toolkit - <a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH</a>
						maintained under umbrella of OpenJDK. It's very flexible and easy to use.
					</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#jmh">See benchmark runner configuration</a>
					</p>
					<pre class="collapse" id="jmh"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/BenchmarkBase.java"
						data-format="lines 17,42"></code></pre>
					<p>
						Most of the benchmarks were run on some elements list of different sizes: <em>1000</em>, <em>10 000</em>,<em>100 000</em>, <em>1 000 000</em> to verify
						how given implementation performs depending on number of elements it has to process.
					</p>
					<p>
						The JVM arguments passed in every test were: <em>-Xms2G -Xmx2G -XX:+UseG1GC</em>. The JVM version used was: <em>Java HotSpot(TM) 64-Bit Server
							1.8.0_201</em>.
					</p>
					<p>
						Benchmark results are presented on charts in <em>percents of best result</em> within sample size. Charts are normalized in the way that for given list
						size best score is found and every score is divided by it. Best result is <em>100 %</em>. When you see <em>50 %</em> score on the chart, it means that
						this benchmark was half good as the best one
					</p>
					<p>
						Results are also displayed in tables in <em>number of operations per second</em> unit. Best results are emphasized.
					</p>
					<h2>Sum of integers</h2>
					<p>This is first benchmark comparing performance of summing integer numbers from list.</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#intsum">See benchmark code</a>
					</p>
					<pre class="collapse" id="intsum"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/IntegerSumBenchmark.java"></code></pre>
					<div class="chart" id="streams-sum-int-chart"></div>
					<p class="legend">You can limit series visible on charts by selecting them from the legend at the top right corner.</p>
					<p>And this is results table.</p>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-sum-int-table">
						</tbody>
					</table>
					<p class="legend">You can select rows to make it more readable.</p>
					<p>
						It was easy to predict. We have clear winner: <code>forEach</code>, but it's advantage was decreasing with larger items numbers, especially when compared
						to parallel version of <code>collect</code>. Sequential <code>collect</code> is better on <em>1000</em> elements, but then parallel version starts to move
						ahead. <code>reduce</code> don't perform well at all, worst in almost all cases but again, parallel stream with <code>reduce</code> is doing better when
						sample is bigger.
					</p>
					<p class="note">
						If greatest part of your program is responsible for summing reasonable big number of integers, go for <code>forEach</code>.
					</p>
					<p>
						If you think I'm little bit sarcastic here ... you are right. It's very unlikely that this level of performance optimizations matters, especially in the
						world of <em>REST APIs</em>, <em>Microservices</em> and <em>Event Driven</em> architectures. If we replace <code>Stream.collect()</code> with <code>forEach</code>
						to sum <em>100 000</em> integers obtained via some REST endpoint, we don't profit much. We gain tenths of microseconds compared to seconds required to
						fetch data from database, serialize, transfer over the wire and deserialize.
					</p>
					<h2>Sum of calculations</h2>
					<p>Let's take more realistic task this time: perform some math operation on list of randomly generated floating-point numbers and sum all calculated
						values.</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#doublesum">See benchmark code</a>
					</p>
					<pre class="collapse" id="doublesum"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/DoubleCalculationBenchmark.java"></code></pre>
					<div class="chart" id="streams-sum-double-calculation-chart"></div>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-sum-double-calculation-table">
						</tbody>
					</table>
					<p>
						Well, what a surprise! <code>forEach</code> score is more or less the same as of sequential stream based versions. Parallel stream implementations are
						about 3 - 5 times faster. Actually, such results are quite easy to explain.
					</p>
					<p class="note">
						There are cost related to <code>Stream</code> creation and threads coordination that can't be mitigated when number of operations to parallelise is small
						or the operation itself is fast.
					</p>
					<p>
						We didn't observe such quick benefits of parallel streams in previous benchmark. According to <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's
							law</a> defining theoretical limits of parallelism - the greater part of our program is run sequentially, less parallel it can be. This is exactly the case
						for summing list of integers. Two integers addition is very fast operation, so inherently sequential part responsible for threads synchronization
						prevailed, especially in case of relatively small quantity of items in the list.
					</p>
					<p>
						The same law caused slightly better performance of <code>reduce</code> operation in this benchmark. <code>reduce</code> contract requires to use binary
						associative operation, free from side effects and working on immutable objects. <code>Double.sum()</code> falls into this category. If we obey these
						constraints, no synchronization is required during partial results merge.
					</p>
					<h2>Grouping</h2>
					<p>
						Grouping some data set is easy, concise and very descriptive with streams therefore is really frequently used, at least in the code I see on a daily
						basis. This feature was compared with version implemented imperatively using <code>forEach</code> loop in this benchmark. There are plenty of variations
						that might affect performance: stream can be sequential or parallel, ordered o unordered, we have several options choosing collector. We can use <code>Stream.reduce()</code>
						operator instead of <code>Stream.collect()</code> or different data structures as grouping containers.
					</p>
					<p>
						The benchmarked task is: take list of randomly generated <code>Double</code>'s group by result of division by 100. Produced result is of type <code
							class="text-nowrap">Map&lt;Double, List&lt;Double&gt;&gt;</code>.
					</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#group">See benchmark code</a>
					</p>
					<pre class="collapse" id="group"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/GroupBenchmark.java"></code></pre>
					<div class="chart-lg" id="streams-group-chart"></div>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-group-table">
						</tbody>
					</table>
					<p>
						Streams based implementation have won the competition again. Careful selection of target data structure made some difference for both: <code>Stream.collect()</code>
						and <code>forEach</code> based solutions. Parallel streams didn't do well until all possible optimizations were applied: parallel unordered stream,
						concurrent collector with linked list. Reduction with immutable collections taken from <a href="https://www.vavr.io/">Vavr</a> library performed poorly,
						mostly due to <code>Map</code> performance characteristics, it's <code>put()</code> and <code>get()</code> methods has <em>effective O(1)</em> time
						complexity.
					</p>
					<p>
						There is severe performance loss visible between <em>10 000</em> and <em>100 000</em> items count I'm not able to explain. This effect is not visible for
						reduction based implementations. You can easily spot it on below chart with Y axis is in logarithmic scale. Every result is divided by best result of the
						same benchmark but different sample size. For smallest list size <em>1000</em>, score is <em>100 %</em>.
					</p>
					<div class="chart-lg" id="streams-group-chart-bench"></div>
					<p>
						Consecutive runs were given 10 times larger list. In ideal world, results should be: <em>100 %</em>, <em>10 %</em>, <em>1 %</em> and <em>0.1 %</em>. Given
						10 times larger list performance would be 10 times worse, but it's not the case for executed benchmarks and is more significant for all grouping
						implementations except those based on reduction and immutable data structures.
					<h2>Filtering and sorting distinct items</h2>
					<p>
						Yet another frequently used features of <code>Stream</code>: filtering, sorting and distinct items selection. Maybe not all together but separately for
						sure. This benchmark takes random decimal numbers, filter by predefined minimal and maximum value, takes distinct values and sort in natural order.
					</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#fitersort">See benchmark code</a>
					</p>
					<pre class="collapse" id="fitersort"><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/FilterSortDistinctBenchmark.java"></code></pre>
					<div class="chart" id="streams-filter-sort-distinct-chart"></div>
					<table class="table table-hover table-sm benchmark">
						<thead>
							<tr>
								<th>Benchmark</th>
								<th class="text-right">1000</th>
								<th class="text-right">10,000</th>
								<th class="text-right">100,000</th>
								<th class="text-right">1000,000</th>
							</tr>
						</thead>
						<tbody id="streams-filter-sort-distinct-table">
						</tbody>
					</table>
					<p>Yet again, stream based code is the winner and common pattern reveals: parallel stream are better when given list becomes longer.</p>
					<h2>Words frequency</h2>
					<p>
						This test is inspired by talk I attended at <em>Geecon 2019</em> conference where I saw the performance comparison of old school Java code and Java 8
						Streams based code. I think that speaker's message was not exactly that Java 8 streams are slow but anyway, presented code triggered my curiosity.
					</p>
					<p>
						The task is: read text file, split into words, count all words, count number of occurrences of every word, display 10 most frequent words. Frequency is
						simply <em>word count/total words count</em>.
					</p>
					<h3>Original code</h3>
					<p>This is original code copied from authors Github repository with irrelevant adjustments.</p>
					<p>This is original old school Java 2 based implementation:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/wfc/CalculatorJ2.java"></code></pre>
					<p>This is original Java 8 Streams based implementation:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/wfc/CalculatorJ8Prl.java"></code></pre>
					<p>This is additional class used for results display:</p>
					<pre><code class="language-java" data-src="../src/main/java/tech/daniellas/wfc/WordFrequency.java"></code></pre>
					<p>This is benchmark code:</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/WfcBenchmark.java" data-format="lines 24,60"></code></pre>
					<p>Below are benchmark results:</p>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table">
								</tbody>
							</table>
						</div>
					</div>
					<p>My first thoughts: not very impressive ... should we really forget about Java 8 Streams where performance matters? But wait, this code looks
						suspicious:</p>
					<ol>
						<li>Is it reasonable to use parallel stream for IO operations?</li>
						<li>Is it really fair to use regular expressions based string splitting?</li>
						<li>Does it really help using parallel stream whenever possible?</li>
						<li>Is it really good idea to create intermediate collection for every operation we perform?</li>
					</ol>
					<p>Lets try to get rid of above doubts and use simple adjustments to improve stream performance.</p>
					<h3>Step 1 - Using string tokenizer stream and sequential streams</h3>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/WfcBenchmark.java" data-format="lines 62,78"></code></pre>
					<p>
						We use sequential streams because reading file from disk might not be the best candidate for parallelization. In test conditions, there is no IO performed
						because operating system is smart enough to keep frequently read files in memory, but even though <code>Path.lines()</code> created stream is of unknown
						size what is strong limitation too. Instead of splitting string and using flat mapping over stream created from strings array, we flat map over stream
						created from <code>StringTokenizer</code>. This should be more efficient.
					</p>
					<p>
						<a class="ans" data-toggle="collapse" href="#string-tokenizer">See the TokenizerStream code</a>
					</p>
					<pre class="collapse" id="string-tokenizer"><code class="language-java" data-src="../src/main/java/tech/daniellas/wfc/TokenizerStream.java"></code></pre>
					<p>
						Here are <code>java8step1</code> benchmark results.
					</p>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart1"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table1">
								</tbody>
							</table>
						</div>
					</div>
					<p>So far so good, we are better then first stream based approach but still below Java 2 based code. Let's try do better.</p>
					<h3>Step 2 - Parallel streams</h3>
					<p>Using parallel stream with IO operations is disputable but we can definitely transform tokens stream to parallel and unordered without much risk.
						Let's use parallel streams for all operations instead of reading lines from file.</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/WfcBenchmark.java" data-format="lines 80,100"></code></pre>
					<p>Here are the results.</p>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart2"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table2">
								</tbody>
							</table>
						</div>
					</div>
					<p>We are ahead previous competitors now, but not much. Let's try something more.</p>
					<h3>Step 3 - Less collections in between</h3>
					<p>
						Splitting code into well defined functions is the very good practice, but it means more overhead for this kind of tasks. We can easily get rid of one of
						created collections by combining group and total words counter increase into one stream. If we look at previous examples, we can notice that first list is
						just the holder for all words from file. We immediately transform it to <code>Map&lt;String,Long&gt;</code> with <code>Stream.collect()</code>. Later on
						we use all words list to get total words number. To avoid necessity of all words list we can group words counts into custom <code>Map</code>
						implementation counting all <code>put</code> operations.
					</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/WfcBenchmark.java" data-format="lines 102,141"></code></pre>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart3"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table3">
								</tbody>
							</table>
						</div>
					</div>
					<p>Did you notice that we didn't use parallel streams at all? I did it deliberately to verify what optimizations really matter. Avoiding unnecessary
						collections is enough to gain significant performance boost.</p>
					<h3>Step 4 - Single pass parallel</h3>
					<p>If we profit by limiting number of created collections and by using parallel streams, let's see what results will be if we combine both
						improvements.</p>
					<pre><code class="language-java" data-src="../src/test/java/tech/daniellas/streams/WfcBenchmark.java" data-format="lines 143,163"></code></pre>
					<div class="row">
						<div class="col-md-8">
							<div class="chart" id="wfc-chart4"></div>
						</div>
						<div class="col-md-4">
							<table class="table table-hover table-sm benchmark">
								<thead>
									<tr>
										<th>Benchmark</th>
										<th class="text-right">Ops/sec</th>
									</tr>
								</thead>
								<tbody id="wfc-table4">
								</tbody>
							</table>
						</div>
					</div>
					<p>
						This time I'm satisfied. Optimized stream based code is about 3 times faster than original Java 8 example and about 2 times faster than original Java 2
						implementation. To be honest, I must admit that using parallel streams is cheating and <code>CountingMap</code> could be used to optimize Java 2 based
						code. On the other side <code>java8step1</code> did quite well. We already know that <code>Stream</code> requires some additional resources and we benefit
						more when we give it more time to work on given task. There is also very important lesson from <em>Words Frequency</em> example:
					</p>
					<p class="note">Don't use parallel streams blindly, always think if there is any potential for parallelism.</p>
					<h2>Conclusions</h2>
					<p>
						I will be frank with you - I'm really glad that Java 8 <code>Stream</code> is quite good in regards of performance. I'd really miss it's beautiful
						descriptive abstraction if I had to drop it's use due to poor performance. I did my best to perform legitimate benchmarks and I'm convinced by their
						results. If you are not, my dear reader, please let me know.
					</p>
					<p class="note">
						There is one more unknown yet left to be discovered. Our parallel streams share one and only <code>ForkJoinPool</code> within whole JVM. The common
						knowledge is that we should be careful about this, but what are the real numbers ... I don't know. Hopefully, I'll get into it soon.
					</p>
				</div>
			</div>
		</div>
	</article>
	<hr>
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-lg-8 col-md-10 mx-auto">
					<ul class="list-inline text-center">
						<li class="list-inline-item">
							<a href="https://www.linkedin.com/in/daniel-las" target="_blank"> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i
									class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
							</span>
							</a>
						</li>
					</ul>
					<p class="copyright text-muted">
						Copyright &copy; Daniel Łaś 2019, Look and feel forked from <a href="https://startbootstrap.com/template-overviews/clean-blog/" target="blank">Clean
							Blog</a>
					</p>
				</div>
			</div>
		</div>
	</footer>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>
	<div class="alert text-center cookiealert">
		We use cookies to ensure you get the best experience on our site.
		<button class="btn btn-primary btn-sm acceptcookies">I agree</button>
	</div>
	<script src="https://cdn.jsdelivr.net/gh/Wruczek/Bootstrap-Cookie-Alert@gh-pages/cookiealert.js"></script>
	<script src="../js/clean-blog.min.js"></script>
	<script src="../js/examples.1.0.0.min.js"></script>
	<script src="../js/charts.1.0.0.min.js"></script>
</body>
</html>
